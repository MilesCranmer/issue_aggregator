{
  "data":
  {
    "repository":
    {
      "issue":
      {
        "number": 574,
        "title": "[Feature]: Recover up-to-date expression from exported PyTorch model (SingleSymPyModule)",
        "body": "### Feature Request\n\nHi! \r\n\r\nVery cool project! \r\n\r\nI just wanted to suggest the following feature, which I've implemented for myself:\r\n\r\nThe `export_torch.SingleSymPyModule` object only holds the initial expression string at the time of export from a PySR model (Sympy expression).\r\n\r\nI'm considering the use case in which the PyTorch model would be further trained to tweak parameters, and it would be very helpful to then inspect the resulting expression, with updated parameter values. However, there's currently no method to update the string.\r\n\r\nIf this is interesting (either here or in the base [sympytorch](https://github.com/patrick-kidger/sympytorch) project @patrick-kidger ), I'm pasting my implementation below, which returns a Sympy expression that represents the current `SingleSymPyModule` (as an independent function, but could be a proper class `__repr__`).\r\n\r\nIt's based on reverse engineering the recursive `Node` structure so **I'm not entirely sure of my parsing** (specifically, the conditions for deciding the type of node). The way I'm mapping back function names to `sympy.core` also feels a bit too broad (using all public content of that module), but working under a time budget :(\r\n\r\nI did however test with property-based testing (using [hypothesis](https://hypothesis.readthedocs.io)), making sure the round-trip PySR -> SingleSympyModule -> SymPy expression always agreed on output with the initial PySR model, given random choices of input operations for `PySRRegressor`. Seems to work fine. Pasting that below as well.\r\n\r\nThe only thing that's not guaranteed to match is the order of terms. That's fine for my work, plus I'm not sure how much time that would take, but would definitely help to have that as well.\r\n\r\n### Suggestion\r\n\r\n```python\r\ndef sympytorch_expr(model: export_torch.SingleSymPyModule) -> sympy.Expr:\r\n    \"\"\"\r\n    Retrieve the Sympy expression of a SingleSymPyModule.\r\n\r\n    Relies on mapping of Sympy operations in sympy.core.__dict__,\r\n    e.g. {'Mul': sympy.core.mul.Mul}\r\n\r\n    :param model: SingleSymPyModule instance\r\n    :return: Sympy expression\r\n    \"\"\"\r\n    str_repr = _sympytorch_node_repr(model._node)\r\n    sympy_op_mapping = sympy.core.__dict__\r\n    # A modicum of sanitizing\r\n    sympy_op_mapping = {op_name: op for op_name, op in sympy_op_mapping.items()\r\n                        if not op_name.startswith('_')}\r\n    return parse_expr(str_repr, local_dict=sympy_op_mapping)\r\n\r\n\r\ndef _sympytorch_node_repr(node) -> str:\r\n    if _sympytorch_node_is_variable(node):\r\n        return node._name\r\n\r\n    if _sympytorch_node_is_function(node):\r\n        return str(node)\r\n\r\n    if _sympytorch_node_is_parameter(node):\r\n        if isinstance(node._value, torch.nn.Parameter):\r\n            return str(node._value.data.item())\r\n        return str(node._value)\r\n\r\n    else:\r\n        # Remove the qualifier from class name for later parsing from sympy.core\r\n        # e.g. sympy.core.mul.Mul -> Mul\r\n        func_repr = str(node._sympy_func).split('.')[-1].split(\"'\")[0]\r\n        args_repr = [_sympytorch_node_repr(arg) for arg in node._args]\r\n        args_repr = '(' + ', '.join(args_repr) + ')'\r\n        args_repr = func_repr + args_repr\r\n        return args_repr\r\n\r\n\r\ndef _sympytorch_node_is_variable(node) -> bool:\r\n    return hasattr(node, '_name')\r\n\r\n\r\ndef _sympytorch_node_is_function(node) -> bool:\r\n    return issubclass(type(node), sympy.core.function.FunctionClass)\r\n\r\n\r\ndef _sympytorch_node_is_parameter(node) -> bool:\r\n    return not hasattr(node, '_args') or not node._args\r\n```\r\n\r\n### Property-based test\r\n\r\n```python\r\nimport numpy as np\r\nfrom pysr import PySRRegressor\r\nfrom sympy import lambdify\r\n\r\nfrom hypothesis import given, seed, settings, HealthCheck\r\nimport hypothesis.strategies as strat\r\nimport pytest\r\n\r\n\r\n@pytest.fixture\r\ndef data_for_test_sympytorch_repr():\r\n    \"\"\"Cache the data generation to save a little time per example.\"\"\"\r\n    rng = np.random.default_rng(42)\r\n    X = rng.uniform(low=0, high=2, size=(10, 1))\r\n    X_test = rng.uniform(low=2, high=4, size=(10, 1))\r\n    y = 2 * np.cos(X) + X ** 2 - 2\r\n    return X, X_test, y\r\n\r\n\r\n@given(\r\n    binary_operators=strat.sets(strat.sampled_from(['+', '*', '/']),\r\n                                min_size=1, max_size=2),\r\n    unary_operators=strat.sets(strat.sampled_from(['sin', 'log', 'sqrt', 'square']),\r\n                               min_size=1, max_size=2),\r\n)\r\n@settings(max_examples=100,\r\n          deadline=10000,   # Account for variation between example times\r\n          suppress_health_check=[HealthCheck.function_scoped_fixture])\r\n@seed(42)\r\ndef test_sympytorch_repr(binary_operators, unary_operators, data_for_test_sympytorch_repr):\r\n    \"\"\"\r\n    Test invariant = outputs match after round-trip\r\n        PySR model (expression) -> SingleSympyModule -> SymPy expression\r\n\r\n    under random PySR input operators.\r\n    \"\"\"\r\n    X, X_test, y = data_for_test_sympytorch_repr\r\n\r\n    model = PySRRegressor(binary_operators=list(binary_operators),\r\n                          unary_operators=list(unary_operators),\r\n                          niterations=2,\r\n                          deterministic=True,\r\n                          procs=0,\r\n                          random_state=42,\r\n                          temp_equation_file=True,\r\n                          verbosity=0)\r\n    model.fit(X, y)\r\n    torch_model = model.pytorch()\r\n    torch_model_expr = sympytorch_expr(torch_model)\r\n    torch_model_expr_func = lambdify('x0', torch_model_expr, 'numpy')\r\n\r\n    output_expr = torch_model_expr_func(X_test).ravel()\r\n    outupt_pysr = model.predict(X_test).ravel()\r\n    assert np.allclose(output_expr, outupt_pysr)\r\n```",
        "comments":
        {
          "nodes": [],
          "pageInfo":
          {
            "hasNextPage": false,
            "endCursor": null
          }
        }
      }
    }
  }
}