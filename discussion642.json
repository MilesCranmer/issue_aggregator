{
  "data":
  {
    "repository":
    {
      "discussion":
      {
        "number": 642,
        "title": "Evaluation of equations to test data",
        "body": "I found have found it v.time consuming to find the sweet spot of complexity that has the best fit for test data with the higher complexities on the training data overfitting and performing poorly on the test data. \r\n\r\nIn addition I also needed to apply the equations to different subgroups of the data and see how each equation applied to those.\r\n\r\nI have put together some python code to make my life easier, and someone else might find it useful.\r\nIt assumes that in the main database (xlsx), has multiple otherwise identical worksheets, that only differ with the data. For example you can have \"train\", \"test_group1\", \"test_group2\" etc. \r\n\r\nThe output would look something like this: \r\nThis table is for all training and test data combined\r\n![image](https://github.com/MilesCranmer/PySR/assets/127948719/6d338054-2c1a-4fb5-801a-98e7bc88752e)\r\n\r\nThe line graphs separate train and test, and present combined data. Separate line graphs are produced for each subcategory\r\n![image](https://github.com/MilesCranmer/PySR/assets/127948719/c0d4094c-0423-454a-bbb2-eb4a5bce6b80)\r\n\r\nApologies if code is highly unoptimised!\r\n\r\nExample:\r\n\r\n```\r\nimport pandas as pd\r\nimport numpy as np\r\nimport math\r\nimport warnings\r\nimport matplotlib.pyplot as plt\r\nfrom sklearn.metrics import mean_absolute_error, mean_squared_error\r\nfrom tabulate import tabulate\r\n\r\n# Suppress the performance warning\r\nwarnings.simplefilter(action='ignore', category=pd.errors.PerformanceWarning)\r\n\r\n# Define the file paths and sheet names\r\ndata_file_path = \"filepath_database.xlsx\"\r\nsheet_names = [\"Train\",\"Test\"] #works with as many sheet names as you want tested. \r\nnew_label = sheet_names + [\"All Cases\"]\r\nsubgroup_categories = ['All', 'Short', 'Medium', 'Long', 'Eq_Wt'] #Eq_Wt means all groups are given equal weighting even if unequal n. \r\n \r\n# Define the target variable and subcategory criteria\r\ntarget_variable = 'Postoperative_BCVA' #Y\r\nsubcategory_variable = 'Preoperative_BCVA' #column in database that subgroup is based on\r\nshort_threshold = 0.3 #<0.3\r\nmedium_threshold_lower = short_threshold #>=0.3\r\nmedium_threshold_upper = 0.6 #<0.6\r\nlong_threshold = medium_threshold_upper #>=0.6\r\n\r\nequations_df = pd.read_csv(\"filepath_to_hall_of_fame_csv.csv\")\r\nequation_strs = equations_df[\"Equation\"].str.lower().tolist() #lower case to prevent frustrating errors, remove if not relevant. \r\n\r\nall_dfs = {i: pd.read_excel(data_file_path, sheet_name=sheet_name) for i, sheet_name in enumerate(sheet_names)}\r\n\r\n# Define mapping between variable names and column names\r\nvariable_mapping = { #left is variable names in equations, x0,x1,x2,x3 etc. Right are column names in database (xlsx)\r\n    'phaco_ppv': 'Phaco_PPV',\r\n    'eifl_present': 'EIFL_Present',\r\n    'eifl_t': 'EIFL_T',\r\n    'eifl_v': 'EIFL_V',\r\n    'preoperative_bcva': 'Preoperative_BCVA',\r\n    'crt': 'CRT',\r\n    'r_mv': 'R_MV',\r\n    'r_fv': 'R_FV',\r\n    'onl_t': 'ONL_T',\r\n    'onl_mv': 'ONL_MV',\r\n    'onl_fv': 'ONL_FV',\r\n    'inl_t': 'INL_T',\r\n    'inl_mv': 'INL_MV',\r\n    'inl_fv': 'INL_FV'\r\n}\r\n\r\nrelevant_columns = list(variable_mapping.values())\r\n\r\ndef get_sample_values(row):\r\n    sample_values = {key: row[col] for key, col in variable_mapping.items()}\r\n    sample_values.update({ #Add unary variables used in pysr\r\n        'sin': math.sin,\r\n        'relu': lambda x: max(0, x),\r\n        'cond': lambda x, y: y if x > 0 else 0,\r\n        'cos': math.cos,\r\n        'tan': math.tan,\r\n        'exp': math.exp,\r\n        'log': math.log,\r\n        'ln': math.log,\r\n        'sqrt': math.sqrt,\r\n        'square': lambda x: x ** 2,\r\n        'inv': lambda x: 1 / x,\r\n    })\r\n    return sample_values\r\n\r\n#------------------no further customisation required below this line for it to work\r\n\r\n# Eval the equations\r\ndef evaluate_equation(row, equation_str):\r\n    try:\r\n        sample_values = get_sample_values(row)\r\n        return eval(equation_str, sample_values)\r\n    except Exception as e:\r\n        #print(f\"Error evaluating equation on row {row.name}: {e}\")\r\n        return np.nan\r\n\r\nfor i, equation_str in enumerate(equation_strs):\r\n    for x, df in all_dfs.items():\r\n        col_e = f'Eval_{i+1}'\r\n        df[col_e] = df.apply(lambda row: evaluate_equation(row, equation_str), axis=1)\r\n\r\n# Combine all individual DF into a single combined DF\r\ncombined_df = pd.concat(all_dfs.values(), ignore_index=True)\r\nall_dfs['combined'] = combined_df\r\n\r\n# Custom error functions that handle NaN values\r\ndef custom_mean_absolute_error(y_true, y_pred):\r\n    mask = ~np.isnan(y_true) & ~np.isnan(y_pred)\r\n    return np.mean(np.abs(y_true[mask] - y_pred[mask]))\r\n\r\ndef custom_mean_squared_error(y_true, y_pred):\r\n    mask = ~np.isnan(y_true) & ~np.isnan(y_pred)\r\n    return np.sqrt(np.mean((y_true[mask] - y_pred[mask]) ** 2))\r\n\r\ndef get_target_variable(df, category):\r\n    if category == 'All':\r\n        return df[target_variable]\r\n    elif category == 'Short':\r\n        return df[df[subcategory_variable] < short_threshold][target_variable]\r\n    elif category == 'Medium':\r\n        return df[(df[subcategory_variable] >= medium_threshold_lower) & (df[subcategory_variable] < medium_threshold_upper)][target_variable]\r\n    elif category == 'Long':\r\n        return df[df[subcategory_variable] >= long_threshold][target_variable]\r\n    elif category == 'Eq_Wt':\r\n        return df[target_variable]\r\n\r\nnum_equations = len(equation_strs)\r\nnum_dfs = len(all_dfs)\r\nnum_categories = len(subgroup_categories)\r\nmae_lists = np.zeros((num_equations, num_dfs, num_categories))\r\nrmse_lists = np.zeros((num_equations, num_dfs, num_categories))\r\n\r\nfor i, equation_str in enumerate(equation_strs):\r\n    for x, (key, df) in enumerate(all_dfs.items()):\r\n        for j, category in enumerate(subgroup_categories):\r\n            true_data = get_target_variable(df, category)\r\n            estimate_data = df[f'Eval_{i+1}'].reindex(true_data.index)  \r\n\r\n            if j == len(subgroup_categories) - 1:  # If Eq_Wt category\r\n                mae_lists[i][x][j] = np.mean(mae_lists[i][x][j - 3:j])\r\n                rmse_lists[i][x][j] = np.mean(rmse_lists[i][x][j - 3:j])\r\n            else:\r\n                mae_lists[i][x][j] = custom_mean_absolute_error(true_data, estimate_data)\r\n                rmse_lists[i][x][j] = custom_mean_squared_error(true_data, estimate_data)\r\n\r\nmin_mae = np.nanmin(mae_lists, axis=0)  \r\nmin_rmse = np.nanmin(rmse_lists, axis=0) \r\n\r\nmin_mae_eq_num = np.argmin(mae_lists, axis=0)  # Equation number for min MAE\r\nmin_rmse_eq_num = np.argmin(rmse_lists, axis=0)  # Equation number for min RMSE\r\n\r\nround_precision = 5\r\n\r\n# Define the data for the table\r\ndata = [[\"Subgroup Category\", \"Min RMSE\", \"Best Equation Number (RMSE)\"] + [category + \" (RMSE)\" for category in subgroup_categories] + [category + \" (MAE)\" for category in subgroup_categories]]\r\n\r\n#RMSE table\r\nfor category in subgroup_categories:\r\n    category_index = subgroup_categories.index(category)\r\n    min_rmse_value = round(min_rmse[len(all_dfs) - 1, category_index], round_precision)\r\n    equation_number_rmse = min_rmse_eq_num[len(all_dfs) - 1, category_index] + 1\r\n    row_data = [category, min_rmse_value, equation_number_rmse]\r\n    for i in subgroup_categories:\r\n        row_data.append(round(rmse_lists[equation_number_rmse-1, len(all_dfs) - 1, subgroup_categories.index(i)], round_precision))\r\n    for i in subgroup_categories:\r\n        row_data.append(round(mae_lists[equation_number_rmse-1, len(all_dfs) - 1, subgroup_categories.index(i)], round_precision))\r\n    data.append(row_data)\r\n\r\nprint(tabulate(data, tablefmt=\"grid\"))\r\n\r\ndata = [[\"Subgroup Category\", \"Min MAE\", \"Best Equation Number (MAE)\"] + [category + \" (RMSE)\" for category in subgroup_categories] + [category + \" (MAE)\" for category in subgroup_categories]]\r\n\r\n#MAE table\r\nfor category in subgroup_categories:\r\n    category_index = subgroup_categories.index(category)\r\n    min_mae_value = round(min_mae[len(all_dfs) - 1, category_index], round_precision)\r\n    equation_number_mae = min_mae_eq_num[len(all_dfs) - 1, category_index] + 1\r\n    row_data = [category, min_mae_value, equation_number_mae]\r\n    for i in subgroup_categories:\r\n        row_data.append(round(rmse_lists[equation_number_mae-1, len(all_dfs) - 1, subgroup_categories.index(i)], round_precision))\r\n    for i in subgroup_categories:\r\n        row_data.append(round(mae_lists[equation_number_mae-1, len(all_dfs) - 1, subgroup_categories.index(i)], round_precision))\r\n    data.append(row_data)\r\n\r\nprint(tabulate(data, tablefmt=\"grid\"))\r\n\r\n# Define x-axis (equation numbers)\r\nx_axis = range(1, len(equation_strs) + 1)\r\n# Calculate the width of the figure based on the number of equations\r\nmin_width = 10  # Minimum width of the figure\r\nadditional_width_per_equation = 0.5  # Additional width per equation\r\nnum_equations = len(equation_strs)\r\ntotal_width = min_width + additional_width_per_equation * num_equations\r\n\r\n# Plot RMSE and MAE for each eye length category\r\nfor j, subgroup_category in enumerate(subgroup_categories):\r\n    plt.figure(figsize=(total_width, 10)) #10 is height of figure, can increase if lots of equations\r\n    for x, df in enumerate(all_dfs):\r\n        label = new_label[x]\r\n        color = plt.cm.tab10(x)\r\n        plt.plot(x_axis, rmse_lists[:, x, j], marker='o', label=label, color=color)\r\n        if label != 'Min Test RMSE':\r\n            plt.axhline(y=min_rmse[x, j], linestyle='--', color=color)\r\n    plt.xlabel('Equation Number')\r\n    plt.ylabel('RMSE')\r\n    plt.title(f'RMSE for Each Equation ({subgroup_category} Eyes)')\r\n    plt.xticks(x_axis)\r\n    plt.legend()\r\n    plt.grid(True)\r\n    plt.show()\r\n    \r\n    plt.figure(figsize=(total_width, 10))\r\n    for x, df in enumerate(all_dfs):\r\n        label = new_label[x]\r\n        color = plt.cm.tab10(x)\r\n        plt.plot(x_axis, mae_lists[:, x, j], marker='o', label=label, color=color)\r\n        if label != 'Min Test MAE':\r\n            plt.axhline(y=min_mae[x, j], linestyle='--', color=color)\r\n    plt.xlabel('Equation Number')\r\n    plt.ylabel('MAE')\r\n    plt.title(f'MAE for Each Equation ({subgroup_category} Eyes)')\r\n    plt.xticks(x_axis)\r\n    plt.legend()\r\n    plt.grid(True)\r\n    plt.show()\r\n\r\n```\r\n  ",
        "comments":
        {
          "nodes": [],
          "pageInfo":
          {
            "hasNextPage": false,
            "endCursor": null
          }
        }
      }
    }
  }
}