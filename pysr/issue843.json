{
  "data": {
    "repository": {
      "issue": {
        "number": 843,
        "title": "[BUG]: Error processing equation '{equation}' in export_sympy.py",
        "body": "### What happened?\n\nI am trying to load model from the previous run:\n```\nmodel = PySRRegressor.from_file(run_directory=\"output/previous_run/\")\n```\n\n\nIf we call parsing directly. It could be floats:\n\n```\n sympify(\"((0.00015137211226844206 + x1) ^ (0.10105096485410878 ^ tanh(atan(asinh(max(max(-0.07533838070355887, (x0 > 0.47902007608623653) - ((x0 * -1.4382635454801191) + 1.3698728108904479)), max(x0, (max(-11.786543789165643, x0 / -1.8955175877405022) - max(log1p(max(x1, 0.03709005706855342)), x0 + 0.6027348964934894)) * max(x0 / -0.655042201185575, 0.12131128801666545))) + atan(atanh(x0 - (max(max(x0, 0.017725367291522368), (-0.07659972979970325 - x0) / -1.7755688550572981) + -0.047919448785427636)))))))) * 0.9946474151515209\")\n\nValueError: Error from parse_expr with transformed code: \"((Float ('0.00015137211226844206' )+Symbol ('x1' ))**(Float ('0.10105096485410878' )**tanh (atan (asinh (max (max (-Float ('0.07533838070355887' ),(Symbol ('x0' )>Float ('0.47902007608623653' ))-((Symbol ('x0' )*-Float ('1.4382635454801191' ))+Float ('1.3698728108904479' ))),max (Symbol ('x0' ),(max (-Float ('11.786543789165643' ),Symbol ('x0' )/-Float ('1.8955175877405022' ))-max (Function ('log1p' )(max (Symbol ('x1' ),Float ('0.03709005706855342' ))),Symbol ('x0' )+Float ('0.6027348964934894' )))*max (Symbol ('x0' )/-Float ('0.655042201185575' ),Float ('0.12131128801666545' ))))+atan (atanh (Symbol ('x0' )-(max (max (Symbol ('x0' ),Float ('0.017725367291522368' )),(-Float ('0.07659972979970325' )-Symbol ('x0' ))/-Float ('1.7755688550572981' ))+-Float ('0.047919448785427636' )))))))))*Float ('0.9946474151515209' )\"\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/core/sympify.py\", line 481, in sympify\n    expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/parsing/sympy_parser.py\", line 1090, in parse_expr\n    raise e from ValueError(f\"Error from parse_expr with transformed code: {code!r}\")\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/parsing/sympy_parser.py\", line 1081, in parse_expr\n    rv = eval_expr(code, local_dict, global_dict)\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/parsing/sympy_parser.py\", line 909, in eval_expr\n    expr = eval(\n           ^^^^^\n  File \"<string>\", line 1, in <module>\nTypeError: unsupported operand type(s) for -: 'StrictGreaterThan' and 'Add'\n>>> Float('177')\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nNameError: name 'Float' is not defined. Did you mean: 'float'?\n```\n\nI get:\n```\nAttempting to load model from tmp/checkpoint.pkl...\nValueError: Error from parse_expr with transformed code: <code object <module> at 0x4de4240, file \"<string>\", line 1>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.12/dist-packages/pysr/export_sympy.py\", line 92, in pysr2sympy\n    return sympify(equation, locals=local_sympy_mappings, evaluate=False)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/core/sympify.py\", line 481, in sympify\n    expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/parsing/sympy_parser.py\", line 1090, in parse_expr\n    raise e from ValueError(f\"Error from parse_expr with transformed code: {code!r}\")\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/parsing/sympy_parser.py\", line 1081, in parse_expr\n    rv = eval_expr(code, local_dict, global_dict)\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/parsing/sympy_parser.py\", line 909, in eval_expr\n    expr = eval(\n           ^^^^^\n  File \"<string>\", line 1, in <module>\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/core/cache.py\", line 72, in wrapper\n    retval = cfunc(*args, **kwargs)\n             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/core/operations.py\", line 64, in __new__\n    raise TypeError(\"Relational cannot be used in %s\" % cls.__name__)\nTypeError: Relational cannot be used in Add\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/mnt/c/py/find_blue3.py\", line 80, in <module>\n    model = PySRRegressor.from_file(run_directory=\"tmp/\")\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.12/dist-packages/pysr/sr.py\", line 1125, in from_file\n    model.refresh()\n  File \"/usr/local/lib/python3.12/dist-packages/pysr/sr.py\", line 2314, in refresh\n    self.equations_ = self.get_hof()\n                      ^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.12/dist-packages/pysr/sr.py\", line 2639, in get_hof\n    self.expression_spec_.create_exports(self, output, search_output),\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.12/dist-packages/pysr/expression_specs.py\", line 88, in create_exports\n    return add_export_formats(\n           ^^^^^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.12/dist-packages/pysr/export.py\", line 38, in add_export_formats\n    eqn = pysr2sympy(\n          ^^^^^^^^^^^\n  File \"/usr/local/lib/python3.12/dist-packages/pysr/export_sympy.py\", line 96, in pysr2sympy\n    raise TypeError(f\"Error processing equation '{equation}'\") from e\nTypeError: Error processing equation '((0.00015137211226844206 + x1) ^ (0.10105096485410878 ^ tanh(atan(asinh(max(max(-0.07533838070355887, (x0 > 0.47902007608623653) - ((x0 * -1.4382635454801191) + 1.3698728108904479)), max(x0, (max(-11.786543789165643, x0 / -1.8955175877405022) - max(log1p(max(x1, 0.03709005706855342)), x0 + 0.6027348964934894)) * max(x0 / -0.655042201185575, 0.12131128801666545))) + atan(atanh(x0 - (max(max(x0, 0.017725367291522368), (-0.07659972979970325 - x0) / -1.7755688550572981) + -0.047919448785427636)))))))) * 0.9946474151515209'\n```\n\nIncluded model in the zip file, so you can reproduce.\nExtract and load.\n\n\nHere is how I made the initial model, could be useful:\n\n```python\nmodel = PySRRegressor(\n    procs=24,\n    niterations=10000,  # Number of iterations\n    maxdepth=20,\n    ncycles_per_iteration=1000,\n    binary_operators=[\"+\", \"-\", \"*\", \"^\", \"/\", \"min\", \"max\", \"cond\", \"greater\", \"logical_or\", \"logical_and\", \"mod\"],  # Binary operations\n    unary_operators=[\"log\", \"log2\", \"log10\", \"abs\", \"sqrt\", \"exp\", \"floor\", \"round\", \"ceil\", \"sin\", \"cos\", \"square\", \"cube\", \"sinh\", \"cosh\", \"tanh\", \"asinh\", \"acosh\", \"atanh\", \"tan\", \"atan\", \"acos\", \"asin\", \"asinh\", \"acosh\", \"atanh\", \"log1p\", \"inv\", \"cbrt\"],  # Unary operations\n    elementwise_loss=\"L2DistLoss()\",  # Loss function\n    populations=75,\n    precision=64, # Do extra float precision could cause parsing issues? \n    turbo=True,\n    verbosity=True,  # Print progress\n    maxsize=300,  # Increase the maximum size of expressions\n)\n```\n\n### Version\n\n1.5.0\n\n### Operating System\n\nLinux\n\n### Package Manager\n\npip\n\n### Interface\n\nScript (i.e., `python my_script.py`)\n\n### Relevant log output\n\n```shell\n\n```\n\n### Extra Info\n\n[model_to_load.zip](https://github.com/user-attachments/files/19024806/model_to_load.zip)",
        "comments": {
          "nodes": [
            {
              "author": {
                "login": "MilesCranmer"
              },
              "body": "I guess it’s from this?\n\n```\nunsupported operand type(s) for -: 'StrictGreaterThan' and 'Add'\n```\n\nNot exactly sure why. Can you remove `greater` as an operator?\n\nBy the way, many of your operators are redundant with eachother—be sure to check out the tuning page. You generally want to use a minimal set of operators for faster searches.",
              "createdAt": "2025-02-28T09:22:22Z"
            },
            {
              "author": {
                "login": "arcusfelis"
              },
              "body": "Hi, I tried to simplify the expression, it fails to parse:\n\n```\nsympify(\"(x0 > 1) - x0\")\nValueError: Error from parse_expr with transformed code: \"(Symbol ('x0' )>Integer (1 ))-Symbol ('x0' )\"\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/core/sympify.py\", line 481, in sympify\n    expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/parsing/sympy_parser.py\", line 1090, in parse_expr\n    raise e from ValueError(f\"Error from parse_expr with transformed code: {code!r}\")\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/parsing/sympy_parser.py\", line 1081, in parse_expr\n    rv = eval_expr(code, local_dict, global_dict)\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/parsing/sympy_parser.py\", line 909, in eval_expr\n    expr = eval(\n           ^^^^^\n  File \"<string>\", line 1, in <module>\nTypeError: unsupported operand type(s) for -: 'StrictGreaterThan' and 'Symbol'\n```\n\nIt fails to part such expression.\n\n\nIf I replace `>` with `+`, it parses just fine (`x0 > 0.47902007608623653` replaced with `x0 + 0.47902007608623653`):\n\n```\n from sympy import sympify\n sympify(\"((0.00015137211226844206 + x1) ^ (0.10105096485410878 ^ tanh(atan(asinh(max(max(-0.07533838070355887, (x0 + 0.47902007608623653) - ((x0 * -1.4382635454801191) + 1.3698728108904479)), max(x0, (max(-11.786543789165643, x0 / -1.8955175877405022) - max(log1p(max(x1, 0.03709005706855342)), x0 + 0.6027348964934894)) * max(x0 / -0.655042201185575, 0.12131128801666545))) + atan(atanh(x0 - (max(max(x0, 0.017725367291522368), (-0.07659972979970325 - x0) / -1.7755688550572981) + -0.047919448785427636)))))))) * 0.9946474151515209\")\n```\n\n\n(I am currently just testing what is possible with expressions, so would optimize when I learn more on the non-optimized solutions :))",
              "createdAt": "2025-02-28T09:31:37Z"
            },
            {
              "author": {
                "login": "arcusfelis"
              },
              "body": "I think sympify has some extra logic and assumptions for `>` operation (i.e. it treats it as boolean and does not allow to easily convert to integer).\n\n```\nsympify(\"greater(x0,4)-x0\")\n-x0 + greater(x0, 4)\n\n sympify(\"(x0>4)-x0\")\nValueError: Error from parse_expr with transformed code: \"(Symbol ('x0' )>Integer (4 ))-Symbol ('x0' )\"\n```",
              "createdAt": "2025-02-28T09:40:06Z"
            },
            {
              "author": {
                "login": "MilesCranmer"
              },
              "body": "Interesting. So, maybe sympy can’t parse `>`?",
              "createdAt": "2025-02-28T09:45:25Z"
            },
            {
              "author": {
                "login": "arcusfelis"
              },
              "body": "Looks like for pysr it treats `>` as:\n```\ngreater is equivalent to (x, y) -> x > y ? 1 : 0\n```\n(from [https://astroautomata.com/PySR/operators/#fn:4](https://astroautomata.com/PySR/operators/#fn:4)).\n\n\nWhile sympy treats it as a boolean operation (the result of that operation is a boolean). A direct conversion is required:\n\n```\nsympify(\"boolean_to_integer(x0>4)-x0\")\n-x0 + boolean_to_integer(x0 > 4)\n```\n\n(ok, there is no boolean_to_integer, but doing some function around it makes it parsable).\n\nSo, sympy thinks `BooleanType - Variable` - illegal.\n\nWe could ask sympy to treat it the same way as `greater is equivalent to (x, y) -> x > y ? 1 : 0`.\n\nOr we need some way to disable error in sympy (just allow it to be, even if it is an invalid operation).\n\nBut yes, sympy does not convert Boolean into Integer (0 or 1) automatically it seams.",
              "createdAt": "2025-02-28T09:52:07Z"
            },
            {
              "author": {
                "login": "arcusfelis"
              },
              "body": "More info:\n```\nsympify(\"(x0 > 0.479) - x0\", evaluate=False)\nValueError: Error from parse_expr with transformed code: <code object <module> at 0x7fccbad25d70, file \"<string>\", line 1>\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/core/sympify.py\", line 481, in sympify\n    expr = parse_expr(a, local_dict=locals, transformations=transformations, evaluate=evaluate)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/parsing/sympy_parser.py\", line 1090, in parse_expr\n    raise e from ValueError(f\"Error from parse_expr with transformed code: {code!r}\")\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/parsing/sympy_parser.py\", line 1081, in parse_expr\n    rv = eval_expr(code, local_dict, global_dict)\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/parsing/sympy_parser.py\", line 909, in eval_expr\n    expr = eval(\n           ^^^^^\n  File \"<string>\", line 1, in <module>\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/core/cache.py\", line 72, in wrapper\n    retval = cfunc(*args, **kwargs)\n             ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/core/operations.py\", line 64, in __new__\n    raise TypeError(\"Relational cannot be used in %s\" % cls.__name__)\nTypeError: Relational cannot be used in Add\n```",
              "createdAt": "2025-02-28T10:13:52Z"
            },
            {
              "author": {
                "login": "MilesCranmer"
              },
              "body": "I wonder if there's a way to override that sympy behavior? Since we would need to parse `sympify(\"(x0 > 0.479) - x0\", evaluate=False)` correctly. I would prefer to not need to handle this on the Julia output side since it is really a sympy issue. But not sure how.",
              "createdAt": "2025-02-28T15:14:55Z"
            },
            {
              "author": {
                "login": "arcusfelis"
              },
              "body": "Oh, **not** easy to override.\nSympy uses python AST parser first and applies a lot of logic after (eval + some optimizations).\nSympy transformations would not work - they are applied in the step after we get the error.\nOverriding operation class in sympy - interesting hack, but even as a hack solution it does not work well, because of optimizations would try to rewrite some expressions.\n\n\n\nIdeally, we wanna do pre-parse step to replace `x > y` with `greater(x,y)` and `x^y` with `power(x,y)`.\n(in sympy, `^` also does not allow some args `TypeError: unsupported operand type(s) for ^: 'Float' and 'Mul'`).\n\nAfter that sympy would just eat the string with custom functions _just fine_.\n\nSympy parser:\nhttps://github.com/sympy/sympy/blob/380a4f9942cc434778222cf5247f2d1492e8f0d1/sympy/parsing/sympy_parser.py#L911",
              "createdAt": "2025-02-28T15:51:39Z"
            },
            {
              "author": {
                "login": "arcusfelis"
              },
              "body": "Another bug (infinite recursion in sympy):\n\n```\n  File \"/usr/local/lib/python3.12/dist-packages/pysr/export_sympy.py\", line 55, in <lambda>\n    \"max\": lambda x, y: sympy.Piecewise((y, x < y), (x, True)),\n                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/functions/elementary/piecewise.py\", line 147, in __new__\n    r = cls.eval(*newargs)\n        ^^^^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/functions/elementary/piecewise.py\", line 203, in eval\n    return cls(*newargs)\n           ^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/functions/elementary/piecewise.py\", line 147, in __new__\n    r = cls.eval(*newargs)\n        ^^^^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/functions/elementary/piecewise.py\", line 203, in eval\n    return cls(*newargs)\n           ^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/functions/elementary/piecewise.py\", line 147, in __new__\n... repeats...\n```\n\nIf we feed that:\n\n```\n'power(0.00015137211226844206 + x1, power(0.10105096485410878, tanh(atan(asinh(max(max(-0.07533838070355887, greater(x0, 0.47902007608623653) - (x0 * -1.4382635454801191 + 1.3698728108904479)), max(x0, (max(-11.786543789165643, x0 / -1.8955175877405022) - max(log1p(max(x1, 0.03709005706855342)), x0 + 0.6027348964934894)) * max(x0 / -0.655042201185575, 0.12131128801666545))) + atan(atanh(x0 - (max(max(x0, 0.017725367291522368), (-0.07659972979970325 - x0) / -1.7755688550572981) + -0.047919448785427636)))))))) * 0.9946474151515209'\n```\n\ninto `sympify(equation, locals=local_sympy_mappings)` (file \"/usr/local/lib/python3.12/dist-packages/pysr/export_sympy.py\")",
              "createdAt": "2025-02-28T16:03:27Z"
            },
            {
              "author": {
                "login": "MilesCranmer"
              },
              "body": "What is the second bug? Can you hit it with the `pysr2sympy` function (which injects the right locals)?",
              "createdAt": "2025-02-28T16:07:58Z"
            },
            {
              "author": {
                "login": "MilesCranmer"
              },
              "body": "`^` should already work, no? Why convert to `power`? (Maybe I'm missing something)",
              "createdAt": "2025-02-28T16:08:47Z"
            },
            {
              "author": {
                "login": "arcusfelis"
              },
              "body": "There are two \"modes of operation\", or more like \"modes of failure\" for `^`.\n\npower fails in sympy parser like that:\n\n```python\nfrom sympy.parsing.sympy_parser import parse_expr\n parse_expr(\"((x1 ^ (0.0973955694025659 ^ sin(atan(atan((max(-0.05760134476810092, x0) + x0) - (max(x0, 0.019106692443470227) + -0.031088779345071812)))))) + 0.009134026923606575) * 0.9847486619505854\", evaluate=False)\n<string>:1: SymPyDeprecationWarning:\n\nUsing non-Expr arguments in Add is deprecated (in this case, one of\nthe arguments has type 'Not').\n\nIf you really did intend to use a multiplication or addition operation with\nthis object, use the * or + operator instead.\n\nSee https://docs.sympy.org/latest/explanation/active-deprecations.html#non-expr-args-deprecated\nfor details.\n\nThis has been deprecated since SymPy version 1.7. It\nwill be removed in a future version of SymPy.\n\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/core/_print_helpers.py\", line 29, in __str__\n    return sstr(self, order=None)\n           ^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/printing/printer.py\", line 372, in __call__\n    return self.__wrapped__(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/printing/str.py\", line 995, in sstr\n    s = p.doprint(expr)\n        ^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/printing/printer.py\", line 292, in doprint\n    return self._str(self._print(expr))\n                     ^^^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/printing/printer.py\", line 331, in _print\n    return printmethod(expr, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/printing/str.py\", line 291, in _print_Mul\n    nfactors = pre + [self.parenthesize(a, prec, strict=False)\n                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/printing/str.py\", line 36, in parenthesize\n    return \"(%s)\" % self._print(item)\n                    ^^^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/printing/printer.py\", line 331, in _print\n    return printmethod(expr, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/printing/str.py\", line 52, in _print_Add\n    terms = self._as_ordered_terms(expr, order=order)\n            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/printing/printer.py\", line 349, in _as_ordered_terms\n    return expr.as_ordered_terms(order=order)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/core/expr.py\", line 1135, in as_ordered_terms\n    terms, gens = self.as_terms()\n                  ^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/core/expr.py\", line 1163, in as_terms\n    coeff, _term = term.as_coeff_Mul()\n                   ^^^^^^^^^^^^^^^^^\nAttributeError: 'Not' object has no attribute 'as_coeff_Mul'\n```\n\n\nIf we set `evaluate=True`, we will get another error:\n\n```python\nparse_expr(\"((x1 ^ (0.0973955694025659 ^ sin(atan(atan((max(-0.05760134476810092, x0) + x0) - (max(x0, 0.019106692443470227) + -0.031088779345071812)))))) + 0.009134026923606575) * 0.9847486619505854\")\nValueError: Error from parse_expr with transformed code: \"((Symbol ('x1' )^(Float ('0.0973955694025659' )^sin (atan (atan ((max (-Float ('0.05760134476810092' ),Symbol ('x0' ))+Symbol ('x0' ))-(max (Symbol ('x0' ),Float ('0.019106692443470227' ))+-Float ('0.031088779345071812' )))))))+Float ('0.009134026923606575' ))*Float ('0.9847486619505854' )\"\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/parsing/sympy_parser.py\", line 1090, in parse_expr\n    raise e from ValueError(f\"Error from parse_expr with transformed code: {code!r}\")\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/parsing/sympy_parser.py\", line 1081, in parse_expr\n    rv = eval_expr(code, local_dict, global_dict)\n         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/usr/local/lib/python3.12/dist-packages/sympy/parsing/sympy_parser.py\", line 909, in eval_expr\n    expr = eval(\n           ^^^^^\n  File \"<string>\", line 1, in <module>\nTypeError: unsupported operand type(s) for ^: 'Float' and 'Mul'\n```\n",
              "createdAt": "2025-02-28T16:16:46Z"
            },
            {
              "author": {
                "login": "MilesCranmer"
              },
              "body": "Note that the internal sympy parser works slightly differently, so this doesn't seem to be a PySR bug:\n\n```python\nimport pysr\n\npysr.export_sympy.pysr2sympy(\n    \"((x1 ^ (0.0973955694025659 ^ sin(atan(atan((max(-0.05760134476810092, x0) + x0) - (max(x0, 0.019106692443470227) + -0.031088779345071812)))))) + 0.009134026923606575) * 0.9847486619505854\",\n    feature_names_in=[\"x0\", \"x1\"]\n)\n```\n\nNo issues from this one",
              "createdAt": "2025-02-28T16:30:38Z"
            },
            {
              "author": {
                "login": "arcusfelis"
              },
              "body": "Oh, I actually managed to start:\n\n```\nmodel = PySRRegressor.from_file(run_directory=\"tmp/\")\nmodel.warm_start = True\nmodel.fit(X, y)\n```\n\nby patching:\n\n```\n\"/usr/local/lib/python3.12/dist-packages/pysr/export_sympy.py\"\n```\n\nWe do:\n- preparse step to rewrite `greater` and `power` - maybe power would not be needed in the final code.\n- we still get infinite loop in`max` operation though, so we I temporary disabled `sympy_mappings` - interesting bug to debug.\n- it parses fine and starts.\n\n- But the model training starts from the beginning :(.\n- I've seen your discussion about https://github.com/MilesCranmer/PySR/discussions/313 - it is possible to do warm start, but only if julia state is present (which we dont have, so we have the expected behaviour - warm start does not work).\n- I have an idea - it would be cool to be able to warm restart if we have power outage (or how I call it \"windows decides to install updates and will not ask for consent\"-outage). Maybe saving julia state should be by default, or behind some option, like `allow_warm_starts_with_hall_of_fame_pkls`, if writing julia state is slow? But otherwise, are there any recommendations, how to write julia state, maybe some hook, when we write hall_of_fame files periodically.\n\n\n\nThis code is similar to what sympy parser calls, also AST lib - but with different transformer class.\n\n```python\n# ... existing code untouched\n# ...\n\nimport ast\n\nclass ExpressionTransformer(ast.NodeTransformer):\n    def visit_Compare(self, node):\n        # Process children nodes first\n        node = self.generic_visit(node)\n        if len(node.ops) == 1:\n            op = node.ops[0]\n            func_map = {\n                ast.Gt: 'greater',\n                ast.GtE: 'greater_equal',\n                ast.Lt: 'less',\n                ast.LtE: 'less_equal',\n                ast.Eq: 'equal',\n                ast.NotEq: 'not_equal',\n            }\n            func_name = func_map.get(type(op))\n            if func_name:\n                return ast.Call(\n                    func=ast.Name(id=func_name, ctx=ast.Load()),\n                    args=[node.left, node.comparators[0]],\n                    keywords=[]\n                )\n        return node\n\n    def visit_BinOp(self, node):\n        # Patch \"^\" operation - it has different meaning in Python\n        # In sympy it is power\n        # Process children nodes first\n        node = self.generic_visit(node)\n        if isinstance(node.op, ast.BitXor):\n            return ast.Call(\n                func=ast.Name(id='power', ctx=ast.Load()),\n                args=[node.left, node.right],\n                keywords=[]\n            )\n        return node\n\ndef transform_expression(expr):\n    try:\n        tree = ast.parse(expr, mode='eval')\n        transformer = ExpressionTransformer()\n        new_tree = transformer.visit(tree)\n        ast.fix_missing_locations(new_tree)\n        return ast.unparse(new_tree)\n    except SyntaxError as e:\n        raise ValueError(f\"Invalid expression: {e}\") from e\n\n\ndef pysr2sympy(\n    equation: str | float | int,\n    *,\n    feature_names_in: ArrayLike[str] | None = None,\n    extra_sympy_mappings: dict[str, Callable] | None = None,\n):\n    if feature_names_in is None:\n        feature_names_in = []\n    local_sympy_mappings = {\n        **create_sympy_symbols_map(feature_names_in),\n        **(extra_sympy_mappings if extra_sympy_mappings is not None else {}),\n        # XXX max would cause infinite loop in pysr, disable mappings\n#       **sympy_mappings,\n    }\n\n    try:\n        # Do preparsing\n        equation = transform_expression(equation)\n        return sympify(equation, locals=local_sympy_mappings, evaluate=False)\n    # XXX Print all errors, not just TypeError\n    except Exception as e:\n        if \"got an unexpected keyword argument 'evaluate'\" in str(e):\n            return sympify(equation, locals=local_sympy_mappings)\n        raise TypeError(f\"Error processing equation '{equation}'\") from e\n```\n",
              "createdAt": "2025-02-28T16:34:30Z"
            },
            {
              "author": {
                "login": "MilesCranmer"
              },
              "body": "Fixed in #845 after SymbolicML/DynamicExpressions.jl#122 and MilesCranmer/SymbolicRegression.jl#431",
              "createdAt": "2025-03-01T18:38:13Z"
            }
          ],
          "pageInfo": {
            "hasNextPage": false,
            "endCursor": "Y3Vyc29yOnYyOpHOoHomgQ=="
          }
        }
      }
    }
  }
}