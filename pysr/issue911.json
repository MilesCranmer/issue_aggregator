{
  "data": {
    "repository": {
      "issue": {
        "number": 911,
        "title": "[BUG]: Expresion template has not attribute sympy",
        "body": "### What happened?\n\nI have dfined a template expresion and I can't get the sympy expresion of the model. It worked perfectly fine without that, but I wanted to yield expresions of 2 variables but I need a sympy expresion te evaluate the result and plot the function.\n\nHere is my function and an example:\n\n```\nimport numpy as np\nimport pandas as pd\nfrom sklearn.model_selection import train_test_split\nfrom pysr import PySRRegressor, TemplateExpressionSpec\n\ndef symbolic_regression(df, input_cols, target_col, threshold=0.2):\n    X = df[input_cols].values\n    y = df[target_col].values\n\n    # Split the data\n    X_train, X_test, y_train, y_test = train_test_split(\n        X, y, test_size=0.3, random_state=12\n    )\n\n    if len(input_cols) == 2:\n        spec = TemplateExpressionSpec(\n            expressions=[\"f\"],\n            variable_names=[\"x0\", \"x1\"],\n            combine=\"f(x0, x1)\"\n        )\n    else:\n        spec = TemplateExpressionSpec(\n            expressions=[\"f\"],\n            variable_names=[\"x0\"],\n            combine=\"f(x0)\"\n        )\n\n    model = PySRRegressor(\n        binary_operators=[\"+\", \"-\", \"*\", \"/\", \"^\"],\n        unary_operators=[\"exp\", \"log\", \"sqrt\"],\n        model_selection=\"best\",\n        verbosity=0,\n        constraints={'^': (-2, 2)},\n        expression_spec=spec\n    )\n\n    model.fit(X_train, y_train)\n    y_pred = model.predict(X_test)\n\n    return model.sympy()\n\n# --------------------------\n# Example\n# --------------------------\n\n\nnp.random.seed(0)\nx = np.random.uniform(-2, 2, 100)\ny = np.random.uniform(-2, 2, 100)\nz = 3 * x + 2 * y + np.sin(x)  \n\ndf = pd.DataFrame({\n    \"x\": x,\n    \"y\": y,\n    \"z\": z\n})\n\n\nexpr = symbolic_regression(df, input_cols=[\"x\", \"y\"], target_col=\"z\")\nprint(expr)\n\n     \n```\n\nCode example\n\n### Version\n\n1.5.6\n\n### Operating System\n\nWindows\n\n### Package Manager\n\nOther (specify below)\n\n### Interface\n\nScript (i.e., `python my_script.py`)\n\n### Relevant log output\n\n```shell\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nCell In[1], line 59\n     52 df = pd.DataFrame({\n     53     \"x\": x,\n     54     \"y\": y,\n     55     \"z\": z\n     56 })\n     58\n---> 59 expr = symbolic_regression(df, input_cols=[\"x\", \"y\"], target_col=\"z\")\n     60 print(expr)\n\nCell In[1], line 40, in symbolic_regression(df, input_cols, target_col, threshold)\n     37 model.fit(X_train, y_train)\n     38 y_pred = model.predict(X_test)\n---> 40 return model.sympy()\n\nFile c:\\Users\\alvar\\Desktop\\UCM\\Cuarto Curso\\TFG\\.venv\\Lib\\site-packages\\pysr\\sr.py:2437, in PySRRegressor.sympy(self, index)\n   2419 \"\"\"\n   2420 Return sympy representation of the equation(s) chosen by `model_selection`.\n   2421 \n   (...)\n   2434     SymPy representation of the best equation.\n   2435 \"\"\"\n   2436 if not self.expression_spec_.supports_sympy:\n-> 2437     raise ValueError(\n   2438         f\"`expression_spec={self.expression_spec_}` does not support sympy export.\"\n   2439     )\n   2440 self.refresh()\n   2441 best_equation = self.get_best(index=index)\n\nValueError: `expression_spec=<pysr.expression_specs.TemplateExpressionSpec object at 0x000001CC97F84090>` does not support sympy export.\n```\n\n### Extra Info\n\nI'm using poetry created a virtual enviroment so I'm running my script like using a regular enviroment, I'm not doing `poetry run something.py`",
        "comments": {
          "nodes": [
            {
              "author": {
                "login": "PhyAMR"
              },
              "body": "I found a solution to the problem\n```\n\n\nimport numpy as np\nimport pandas as pd\nfrom sklearn.model_selection import train_test_split\nfrom pysr import PySRRegressor, TemplateExpressionSpec\nfrom sympy import symbols\nfrom sympy.parsing.sympy_parser import parse_expr, standard_transformations, implicit_multiplication_application\n\ndef symbolic_regression(df, input_cols, target_col, threshold=0.2):\n    X = df[input_cols].values\n    y = df[target_col].values\n\n    # Split the data\n    X_train, X_test, y_train, y_test = train_test_split(\n        X, y, test_size=0.3, random_state=12\n    )\n\n    if len(input_cols) == 2:\n        spec = TemplateExpressionSpec(\n            expressions=[\"f\"],\n            variable_names=[\"x0\", \"x1\"],\n            combine=\"f(x0, x1)\"\n        )\n    else:\n        spec = TemplateExpressionSpec(\n            expressions=[\"f\"],\n            variable_names=[\"x0\"],\n            combine=\"f(x0)\"\n        )\n\n    model = PySRRegressor(\n        binary_operators=[\"+\", \"-\", \"*\", \"/\", \"^\"],\n        unary_operators=[\"exp\", \"log\", \"sqrt\"],\n        model_selection=\"best\",\n        verbosity=0,\n        constraints={'^': (-2, 2)},\n        expression_spec=spec\n    )\n\n    model.fit(X_train, y_train)\n    y_pred = model.predict(X_test)\n\n    return model.get_best()['equation']\n\n# --------------------------\n# Ejemplo para probarla\n# --------------------------\n\n# Crear un DataFrame con una función conocida de dos variables\nnp.random.seed(0)\nx = np.random.uniform(-2, 2, 100)\ny = np.random.uniform(-2, 2, 100)\nz = 3 * x + 2 * y + np.sin(x)  # relación no lineal simple\n\ndf = pd.DataFrame({\n    \"x\": x,\n    \"y\": y,\n    \"z\": z\n})\n\n# Ejecutar la función\nexpr = symbolic_regression(df, input_cols=[\"x\", \"y\"], target_col=\"z\")\nprint(expr)\n\n\n\n# Define the symbols\nx0, x1 = symbols(\"x0 x1\")\n\n# Define the local dictionary for variable mapping\nlocal_dict = {\"x0\": x0, \"x1\": x1}\nrhs = expr.split('=', 1)[1].strip()\nrhs = rhs.replace(\"^\", \"**\")\nf = rhs.replace(\"#1\", \"x0\").replace(\"#2\", \"x1\")\n\n# Define the transformations to handle implicit multiplication\ntransformations = standard_transformations + (implicit_multiplication_application,)\n\n# Parse the expression\nexpr2 = parse_expr(f, local_dict=local_dict, transformations=transformations)\nprint(expr2)\nfrom sympy import lambdify\n\n# Create a numerical function\nf_numeric = lambdify((x0, x1), expr2, modules=\"numpy\")\n\n# Evaluate the function\nresult = f_numeric(1.0, 2.0)\n\nprint(result)\n\n```",
              "createdAt": "2025-05-05T01:02:57Z"
            },
            {
              "author": {
                "login": "PhyAMR"
              },
              "body": "Also but maybe for another BUG (let me know if that is the case) I want to ensure that the expresion matches the number of input cols (even if I get a worst fit) to do so (and after I couldn't find anything in the docs) chatgpt gave me this line for the template:\n\n```\nspec = TemplateExpressionSpec(\n    expressions=[\"f\", \"g\"],\n    variable_names=[\"x0\", \"x1\"],\n    combine=\"((; f, g), (x0, x1)) -> f(x0) + g(x1)\"\n)\n```\n\nBut it gives me this error with julia:\n\n```\nArgumentError: Failed to infer number of features used by (:f, :g)\nStacktrace:\n  [1] infer_variable_constraints(::Val{(:f, :g)}, num_parameters::NamedTuple, combiner::Any)\n    @ SymbolicRegression.TemplateExpressionModule C:\\Users\\alvar\\.julia\\packages\\SymbolicRegression\\BBPwF\\src\\TemplateExpression.jl:238\n  [2] macro expansion\n    @ .\\some.jl:158 [inlined]\n  [3] #_#2\n    @ C:\\Users\\alvar\\.julia\\packages\\SymbolicRegression\\BBPwF\\src\\TemplateExpression.jl:141 [inlined]\n  [4] TemplateStructure\n    @ C:\\Users\\alvar\\.julia\\packages\\SymbolicRegression\\BBPwF\\src\\TemplateExpression.jl:122 [inlined]\n  [5] #_#1\n    @ C:\\Users\\alvar\\.julia\\packages\\SymbolicRegression\\BBPwF\\src\\TemplateExpression.jl:118 [inlined]\n  [6] TemplateStructure\n    @ C:\\Users\\alvar\\.julia\\packages\\SymbolicRegression\\BBPwF\\src\\TemplateExpression.jl:112 [inlined]\n  [7] (TemplateStructure{(:f, :g), Kp, E, NF} where {Kp, E<:Function, NF<:(NamedTuple{(:f, :g)})})(combine::var\"#367#369\")\n    @ SymbolicRegression.TemplateExpressionModule C:\\Users\\alvar\\.julia\\packages\\SymbolicRegression\\BBPwF\\src\\TemplateExpression.jl:112\n  [8] top-level scope\n    @ C:\\Users\\alvar\\.julia\\packages\\SymbolicRegression\\BBPwF\\src\\TemplateExpressionMacro.jl:91\n  [9] eval\n    @ .\\boot.jl:430 [inlined]\n [10] eval\n    @ .\\Base.jl:130 [inlined]\n [11] pyjlmodule_seval(self::Module, expr::Py)\n    @ PythonCall.JlWrap C:\\Users\\alvar\\.julia\\packages\\PythonCall\\WMWY0\\src\\JlWrap\\module.jl:13\n [12] _pyjl_callmethod(f::Any, self_::Ptr{PythonCall.C.PyObject}, args_::Ptr{PythonCall.C.PyObject}, nargs::Int64)\n    @ PythonCall.JlWrap C:\\Users\\alvar\\.julia\\packages\\PythonCall\\WMWY0\\src\\JlWrap\\base.jl:67\n [13] _pyjl_callmethod(o::Ptr{PythonCall.C.PyObject}, args::Ptr{PythonCall.C.PyObject})\n    @ PythonCall.JlWrap.Cjl C:\\Users\\alvar\\.julia\\packages\\PythonCall\\WMWY0\\src\\JlWrap\\C.jl:63\n\n```",
              "createdAt": "2025-05-05T01:07:55Z"
            }
          ],
          "pageInfo": {
            "hasNextPage": false,
            "endCursor": "Y3Vyc29yOnYyOpHOqdqjww=="
          }
        }
      }
    }
  }
}