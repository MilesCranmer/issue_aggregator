{
  "data": {
    "repository": {
      "discussion": {
        "number": 812,
        "title": "Converging in complex equations with absolute truth",
        "body": "Hi All, \r\nI am working on a problem of measuring the distance between the apices of two triangles that share the same base, which can be a useful prognostic sign in ocular imaging. \r\n![image](https://github.com/user-attachments/assets/6ec284f4-360e-457b-99e3-8021b891664f)\r\n\r\nI have derived the formula geometrically:\r\n\r\n$\\frac{\\sqrt{\\left(\\sqrt{4a^2c^2 - (a^2 - b^2 + c^2)^2} - \\sqrt{4c^2x^2 - (c^2 + x^2 - y^2)^2}\\right)^2 + (a^2 - b^2 - x^2 + y^2)^2}}{2c}$\r\n(complexity 74)\r\n\r\nI can actually break it up into much simpler equations:\r\n```julia \r\n    xP = (a^2 - b^2 + c^2)/(2c)\r\n    yP = sqrt(a^2 - xP^2)\r\n    xQ = (x^2 - y^2 + c^2)/(2c)\r\n    yQ = sqrt(x^2 - xQ^2)\r\n    sqrt((xP - xQ)^2 + (yP - yQ)^2)\r\n```\r\n\r\nI was very interested to see how close SR would cope with this. \r\nI managed to get an MSE of about 2e+03. I was wondering if anyone has solved more complicated expressions like this with SR and GP?\r\n\r\nThis code generates 50 datapoints for two triangles that share a base\r\n```Julia\r\nusing SymbolicRegression, IterTools, LoopVectorization, Bumper, MLJ, DataFrames, Random\r\n\r\nis_valid_triangle(u,v,w) = (u+v>w) && (v+w>u) && (w+u>v)\r\nfunction random_triangle(low,high)\r\n    while true\r\n        a,b,c = rand(low:high), rand(low:high), rand(low:high)\r\n        is_valid_triangle(a,b,c) && return (a,b,c)\r\n    end\r\nend\r\n\r\n#distance between PQ on shared base c using circle formula.\r\nfunction dist_PQ(a,b,c,x,y)\r\n    xP = (a^2 - b^2 + c^2)/(2c)\r\n    yP = sqrt(a^2 - xP^2)\r\n    xQ = (x^2 - y^2 + c^2)/(2c)\r\n    yQ = sqrt(x^2 - xQ^2)\r\n    sqrt((xP - xQ)^2 + (yP - yQ)^2) #all-in-one function: sqrt((sqrt(4*a^2*c^2 - (a^2 - b^2 + c^2)^2) - sqrt(4*c^2*x^2 - (c^2 + x^2 - y^2)^2))^2 + (a^2 - b^2 - x^2 + y^2)^2)/(2*c) complexity: 74\r\nend\r\nfunction generate_data(N=50; low=200, high=5000, seed=1) #larger triangles have higher MSE. \r\n    Random.seed!(seed)\r\n    df = DataFrame(c=Float64[], a=Float64[], b=Float64[],\r\n                   x=Float64[], y=Float64[], Distance=Float64[])\r\n    for _ in 1:N\r\n        a1,b1,c1 = random_triangle(low,high)\r\n        while true\r\n            x1,y1 = rand(low:high), rand(low:high)\r\n            is_valid_triangle(x1,y1,c1) && begin\r\n                push!(df, (c1,a1,b1,x1,y1, dist_PQ(a1,b1,c1,x1,y1)))\r\n                break\r\n            end\r\n        end\r\n    end\r\n    df\r\nend\r\n\r\ndf_triang = generate_data(50)\r\n\r\nX = select(df_triang, :c, :a, :b, :x, :y)\r\ny = df_triang[!, :Distance]\r\n\r\nmodel = SRRegressor(\r\n    niterations=1000000,\r\n    binary_operators=[+, -, *, /],\r\n    unary_operators=([square, sqrt]),\r\n    nested_constraints=[\r\n    sqrt => [sqrt => 5, square => 20],\r\n    square => [sqrt => 5, square => 20]\r\n    ],\r\n    maxsize=100,\r\n    bumper=true,\r\n    turbo=true,\r\n    populations=18,\r\n    population_size=1000,\r\n)\r\nmach = machine(model, X, y)\r\nfit!(mach)\r\n``` \r\nPerhaps breaking the problem down into smaller functions with TemplateExpressions is the way to go, but it's difficult to do that if there was no priori, or much more compute might be necessary.",
        "comments": {
          "nodes": [
            {
              "author": {
                "login": "gm89uk"
              },
              "body": "FYI @MilesCranmer \r\n\r\nThis relates to the discussion here #798 \r\nI am getting no convergence with default adaptive_parsimony_scaling and it only converges when this is set to 20 (v1.5.2 SR.jl). \r\n\r\nNo convergence: \r\n```julia\r\nusing SymbolicRegression, IterTools, LoopVectorization, Bumper, MLJ, DataFrames, Random\r\n\r\nis_valid_triangle(u,v,w) = (u+v>w) && (v+w>u) && (w+u>v)\r\nfunction random_triangle(low,high)\r\n    while true\r\n        a,b,c = rand(low:high), rand(low:high), rand(low:high)\r\n        is_valid_triangle(a,b,c) && return (a,b,c)\r\n    end\r\nend\r\nfunction dist_PQ(a,b,c,x,y)\r\n    xP = (a^2 - b^2 + c^2)/(2c)\r\n    yP = sqrt(a^2 - xP^2)\r\n    xQ = (x^2 - y^2 + c^2)/(2c)\r\n    yQ = sqrt(x^2 - xQ^2)\r\n    sqrt((xP - xQ)^2 + (yP - yQ)^2) #all-in-one function: sqrt((sqrt(4*a^2*c^2 - (a^2 - b^2 + c^2)^2) - sqrt(4*c^2*x^2 - (c^2 + x^2 - y^2)^2))^2 + (a^2 - b^2 - x^2 + y^2)^2)/(2*c) complexity: 74\r\nend\r\nfunction generate_data(N=20; low=200, high=5000, seed=1)\r\n    Random.seed!(seed)\r\n    df = DataFrame(c=Float64[], a=Float64[], b=Float64[],\r\n                   x=Float64[], y=Float64[], Distance=Float64[])\r\n    for _ in 1:N\r\n        a1,b1,c1 = random_triangle(low,high)\r\n        while true\r\n            x1,y1 = rand(low:high), rand(low:high)\r\n            is_valid_triangle(x1,y1,c1) && begin\r\n                push!(df, (c1,a1,b1,x1,y1, dist_PQ(a1,b1,c1,x1,y1)))\r\n                break\r\n            end\r\n        end\r\n    end\r\n    df\r\nend\r\n\r\ndf_triang = generate_data(200)\r\nX = select(df_triang, :c, :a, :b, :x, :y)\r\ny = df_triang[!, :Distance]\r\ndouble(x)=2*x\r\nmodel = SRRegressor(\r\n    niterations=1000000,\r\n    binary_operators=[+, -, *, /],\r\n    unary_operators=([square, sqrt, double]),\r\n    nested_constraints=[\r\n    sqrt => [sqrt => 5, square => 20],\r\n    square => [sqrt => 5, square => 20],\r\n    double => [double => 2],\r\n    ],\r\n    maxsize=120,\r\n    bumper=true,\r\n    turbo=true,\r\n    populations=18,\r\n    #adaptive_parsimony_scaling=20,\r\n    population_size=100,\r\n    complexity_of_constants = 1000,\r\n)\r\nmach = machine(model, X, y)\r\nfit!(mach)\r\n```\r\nChanging `adaptive_parsimony_scaling=20` works.\r\n\r\n\r\n\r\n",
              "createdAt": "2025-01-21T23:55:02Z"
            }
          ],
          "pageInfo": {
            "hasNextPage": false,
            "endCursor": "Y3Vyc29yOnYyOpK5MjAyNS0wMS0yMVQyMzo1NTowMiswMDowMM4Atbcz"
          }
        }
      }
    }
  }
}