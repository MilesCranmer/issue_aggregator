{
  "data": {
    "repository": {
      "discussion": {
        "number": 746,
        "title": "How to Implement a Custom Integral-Based Loss in Julia for PySR and Retrieve Predicted Integral Values",
        "body": "Hello @MilesCranmer ,\r\n\r\nI’m trying to implement a custom loss function in Julia string  to use with PySR, and I’m encountering some issues. Here’s what I’m aiming to achieve\r\nI want to constrain the distribution H^{u-d} (X,0,t)  with a specific moment formula at several values of t  Specifically, I have a target formula like this  int H^{u-d}(X, 0, t) dx = A_{10}^{u-d} (t) where t takes on around 10 specific values, and I want to calculate the integral of  H^{u-d} (X,0,t).\r\nThe custom loss should compute the difference between this integral and the target values A_{10}^{u-d}  (t) at each \r\nt value. I plan to sum up these differences (or take an average) to create the final loss.\r\n\r\nI attempted to implement this in Julia by evaluating  H^{u-d} (X,0,t) (assumed to be represented by PySR’s predictions) and then using quadgk for numerical integration over X from 0 to 1.\r\nI ran into issues with the function signature and type mismatches. PySR seems to pass individual values (like Float32) instead of the expected Dataset structure, which caused errors.\r\n\r\n```\r\nJuliaError: MethodError: no method matching CustomLossWithIntegralConstraint(::Float32, ::Float32)\r\n\r\nClosest candidates are:\r\n  CustomLossWithIntegralConstraint(::Any, !Matched::Dataset{T, L, AX, AY, AW} where {AX<:AbstractMatrix{T}, AY<:Union{Nothing, AbstractVector{T}}, AW<:Union{Nothing, AbstractVector{T}}}, !Matched::Any, !Matched::Any) where {T, L}\r\n   @ Main none:5\r\n```\r\nthis is the first method\r\n```\r\nfunction CustomLossWithIntegralConstraint(tree, dataset::Dataset{T,L}, options, idx)::L where {T,L}\r\n    # Evaluate the symbolic expression (tree) on the dataset to get predictions\r\n    predictions, success = eval_tree_array(tree, dataset.X, options)\r\n    if !success\r\n        return Inf  \r\n    end\r\n\r\n    # Define H^{u-d}(X, 0, t) as a function that depends on `X`\r\n    H_ud(X) = predictions[1]  # Assuming predictions[1] is H^{u-d}(X, 0, t)\r\n\r\n    # Define the target values from the table for each t value\r\n    A10_values = [\r\n        0.851, 0.702, 0.607, 0.573, 0.487, 0.359, 0.396, 0.376, \r\n        0.320, 0.266, 0.214\r\n    ]\r\n\r\n    # Initialize the total loss\r\n    total_loss = 0.0\r\n\r\n    # Iterate over each target value, representing each `t` in the table\r\n    for target_value in A10_values\r\n        # Compute the integral of H^{u-d}(X, 0, t) over X from 0 to 1\r\n        integral_result = quadgk(H_ud, 0, 1)[1]\r\n\r\n        # Calculate the loss as the absolute difference between the integral and the target value\r\n        total_loss += abs(integral_result - target_value)\r\n    end\r\n```\r\n\r\nI have tried another method \r\n```\r\n    individual_differences = []\r\n    for (i, t_i) in enumerate(t_values)\r\n        # Set the number of grid points dynamically based on input data size\r\n        n_grid_points = length(dataset.X[:, 1])  # Match the number of x-values in your dataset\r\n\r\n        # Create a dense grid of x values from 0 to 1\r\n        dense_x = range(0.0, stop=1.0, length=n_grid_points) |> collect\r\n        dense_X_matrix = reshape(dense_x, :, 1)\r\n\r\n        # Construct a dataset where t_i is fixed for each dense_x (input: log(x), log(1-x), log(t))\r\n        dense_X_matrix_t = hcat(log.(dense_x), log.(1 .- dense_x), fill(log(t_i), length(dense_x)))\r\n\r\n        # Evaluate the model on this dense grid\r\n        predictions_dense, flag_dense = eval_tree_array(tree, dense_X_matrix_t, options)\r\n        if !flag_dense\r\n            return Inf\r\n        end\r\n\r\n        # Formula 1: F_{1}(t) (experimental data instead of A_{10}^{u-d}(t))\r\n        integral_F1 = mean(predictions_dense)  # Integral from 0 to 1 is the average\r\n        F1_target = F1_data[i]\r\n        push!(individual_differences, (integral_F1 - F1_target)^2)\r\n```\r\n\r\nby taking the mean for the formula to calculate the integral from 0 to 1 ,but every time I get the same integral predictions for all t values.\r\nI would also like to know how to print individual_differences or any losses from the julia to plot the integrals.\r\nI am suppose to do this integral for five more formulas and add them up to the total loss actually ",
        "comments": {
          "nodes": [],
          "pageInfo": {
            "hasNextPage": false,
            "endCursor": null
          }
        }
      }
    }
  }
}