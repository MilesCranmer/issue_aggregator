{
  "data": {
    "repository": {
      "issue": {
        "number": 949,
        "title": "[BUG]: Getting Domain Error Agian",
        "body": "### What happened?\n\nHi. I am using 1.5.8 version. And I got this error again which was reported before and should be fixed seemingly:\nUNHANDLED TASK ERROR: TaskFailedException\nStacktrace:\n [1] wait(t::Task)\n   @ Base ./task.jl:370\n [2] fetch\n   @ ./task.jl:390 [inlined]\n [3] #63\n   @ ~/.julia/packages/SymbolicRegression/MdISO/src/SymbolicRegression.jl:976\n\n    nested task error: DomainError with Inf:\n    tan(x) is only defined for finite x.\n    Stacktrace:\n      [1] tan_domain_error(x::Float32)\n        @ Base.Math ./special/trig.jl:215\n      [2] tan(x::Float32)\n        @ Base.Math ./special/trig.jl:226\n      [3] macro expansion\n        @ ~/.julia/packages/DynamicExpressions/wtMlL/ext/DynamicExpressionsLoopVectorizationExt.jl:79 [inlined]\n      [4] macro expansion\n        @ ~/.julia/packages/LoopVectorization/ImqiY/src/condense_loopset.jl:1179 [inlined]\n      [5] deg1_l2_ll0_lr0_eval(tree::Node{Float32}, cX::SubArray{Float32, 2, Matrix{Float32}, Tuple{Base.Slice{Base.OneTo{Int64}}, Vector{Int64}}, false}, op::typeof(tan), op_l::typeof(/), eval_options::EvalOptions{true, false, true, Nothing})\n        @ DynamicExpressionsLoopVectorizationExt ~/.julia/packages/DynamicExpressions/wtMlL/ext/DynamicExpressionsLoopVectorizationExt.jl:77\n      [6] macro expansion\n        @ ~/.julia/packages/DynamicExpressions/wtMlL/src/Evaluate.jl:438 [inlined]\n      [7] dispatch_deg1_l2_ll0_lr0_eval\n        @ ~/.julia/packages/DynamicExpressions/wtMlL/src/Evaluate.jl:422 [inlined]\n      [8] macro expansion\n        @ ~/.julia/packages/DynamicExpressions/wtMlL/src/Evaluate.jl:402 [inlined]\n      [9] dispatch_deg1_eval(tree::Node{Float32}, cX::SubArray{Float32, 2, Matrix{Float32}, Tuple{Base.Slice{Base.OneTo{Int64}}, Vector{Int64}}, false}, op_idx::UInt8, operators::OperatorEnum{Tuple{typeof(+), typeof(-), typeof(*), typeof(/)}, Tuple{typeof(cos), typeof(sin), typeof(tan), typeof(safe_log), typeof(safe_sqrt), typeof(inv)}}, eval_options::EvalOptions{true, false, true, Nothing})\n        @ DynamicExpressions.EvaluateModule ~/.julia/packages/DynamicExpressions/wtMlL/src/Evaluate.jl:375\n     [10] _eval_tree_array(tree::Node{Float32}, cX::SubArray{Float32, 2, Matrix{Float32}, Tuple{Base.Slice{Base.OneTo{Int64}}, Vector{Int64}}, false}, operators::OperatorEnum{Tuple{typeof(+), typeof(-), typeof(*), typeof(/)}, Tuple{typeof(cos), typeof(sin), typeof(tan), typeof(safe_log), typeof(safe_sqrt), typeof(inv)}}, eval_options::EvalOptions{true, false, true, Nothing})\n        @ DynamicExpressions.EvaluateModule ~/.julia/packages/DynamicExpressions/wtMlL/src/Evaluate.jl:277\n     [11] macro expansion\n        @ ~/.julia/packages/DynamicExpressions/wtMlL/src/Evaluate.jl:350 [inlined]\n     [12] dispatch_deg2_eval(tree::Node{Float32}, cX::SubArray{Float32, 2, Matrix{Float32}, Tuple{Base.Slice{Base.OneTo{Int64}}, Vector{Int64}}, false}, op_idx::UInt8, operators::OperatorEnum{Tuple{typeof(+), typeof(-), typeof(*), typeof(/)}, Tuple{typeof(cos), typeof(sin), typeof(tan), typeof(safe_log), typeof(safe_sqrt), typeof(inv)}}, eval_options::EvalOptions{true, false, true, Nothing})\n        @ DynamicExpressions.EvaluateModule ~/.julia/packages/DynamicExpressions/wtMlL/src/Evaluate.jl:321\n     [13] _eval_tree_array(tree::Node{Float32}, cX::SubArray{Float32, 2, Matrix{Float32}, Tuple{Base.Slice{Base.OneTo{Int64}}, Vector{Int64}}, false}, operators::OperatorEnum{Tuple{typeof(+), typeof(-), typeof(*), typeof(/)}, Tuple{typeof(cos), typeof(sin), typeof(tan), typeof(safe_log), typeof(safe_sqrt), typeof(inv)}}, eval_options::EvalOptions{true, false, true, Nothing})\n        @ DynamicExpressions.EvaluateModule ~/.julia/packages/DynamicExpressions/wtMlL/src/Evaluate.jl:282\n     [14] macro expansion\n        @ ~/.julia/packages/DynamicExpressions/wtMlL/src/Evaluate.jl:365 [inlined]\n     [15] dispatch_deg2_eval(tree::Node{Float32}, cX::SubArray{Float32, 2, Matrix{Float32}, Tuple{Base.Slice{Base.OneTo{Int64}}, Vector{Int64}}, false}, op_idx::UInt8, operators::OperatorEnum{Tuple{typeof(+), typeof(-), typeof(*), typeof(/)}, Tuple{typeof(cos), typeof(sin), typeof(tan), typeof(safe_log), typeof(safe_sqrt), typeof(inv)}}, eval_options::EvalOptions{true, false, true, Nothing})\n        @ DynamicExpressions.EvaluateModule ~/.julia/packages/DynamicExpressions/wtMlL/src/Evaluate.jl:321\n     [16] _eval_tree_array(tree::Node{Float32}, cX::SubArray{Float32, 2, Matrix{Float32}, Tuple{Base.Slice{Base.OneTo{Int64}}, Vector{Int64}}, false}, operators::OperatorEnum{Tuple{typeof(+), typeof(-), typeof(*), typeof(/)}, Tuple{typeof(cos), typeof(sin), typeof(tan), typeof(safe_log), typeof(safe_sqrt), typeof(inv)}}, eval_options::EvalOptions{true, false, true, Nothing})\n        @ DynamicExpressions.EvaluateModule ~/.julia/packages/DynamicExpressions/wtMlL/src/Evaluate.jl:282\n     [17] eval_tree_array(tree::Node{Float32}, cX::SubArray{Float32, 2, Matrix{Float32}, Tuple{Base.Slice{Base.OneTo{Int64}}, Vector{Int64}}, false}, operators::OperatorEnum{Tuple{typeof(+), typeof(-), typeof(*), typeof(/)}, Tuple{typeof(cos), typeof(sin), typeof(tan), typeof(safe_log), typeof(safe_sqrt), typeof(inv)}}; eval_options::EvalOptions{true, false, true, Nothing}, _deprecated_kws::@Kwargs{})\n        @ DynamicExpressions.EvaluateModule ~/.julia/packages/DynamicExpressions/wtMlL/src/Evaluate.jl:227\n     [18] eval_tree_array\n        @ ~/.julia/packages/DynamicExpressions/wtMlL/src/Evaluate.jl:200 [inlined]\n     [19] eval_tree_array(ex::Expression{Float32, Node{Float32}, @NamedTuple{operators::Nothing, variable_names::Nothing}}, cX::SubArray{Float32, 2, Matrix{Float32}, Tuple{Base.Slice{Base.OneTo{Int64}}, Vector{Int64}}, false}, operators::OperatorEnum{Tuple{typeof(+), typeof(-), typeof(*), typeof(/)}, Tuple{typeof(cos), typeof(sin), typeof(tan), typeof(safe_log), typeof(safe_sqrt), typeof(inv)}}; kws::@Kwargs{eval_options::EvalOptions{true, false, true, Nothing}})\n        @ DynamicExpressions.ExpressionModule ~/.julia/packages/DynamicExpressions/wtMlL/src/Expression.jl:436\n     [20] eval_tree_array(tree::Expression{Float32, Node{Float32}, @NamedTuple{operators::Nothing, variable_names::Nothing}}, X::SubArray{Float32, 2, Matrix{Float32}, Tuple{Base.Slice{Base.OneTo{Int64}}, Vector{Int64}}, false}, options::Options{SymbolicRegression.CoreModule.OptionsStructModule.ComplexityMapping{Int64, Int64}, OperatorEnum, Node, Expression, @NamedTuple{}, MutationWeights, true, false, nothing, Nothing, 5}; turbo::Nothing, bumper::Nothing, kws::@Kwargs{})\n        @ SymbolicRegression.InterfaceDynamicExpressionsModule ~/.julia/packages/SymbolicRegression/MdISO/src/InterfaceDynamicExpressions.jl:81\n     [21] eval_tree_array\n        @ ~/.julia/packages/SymbolicRegression/MdISO/src/InterfaceDynamicExpressions.jl:61 [inlined]\n     [22] eval_tree_dispatch\n        @ ~/.julia/packages/SymbolicRegression/MdISO/src/LossFunctions.jl:68 [inlined]\n     [23] _eval_loss(tree::Expression{Float32, Node{Float32}, @NamedTuple{operators::Nothing, variable_names::Nothing}}, dataset::SymbolicRegression.CoreModule.DatasetModule.SubDataset{Float32, Float32, SymbolicRegression.CoreModule.DatasetModule.BasicDataset{Float32, Float32, Matrix{Float32}, Vector{Float32}, Nothing, @NamedTuple{}, Nothing, Nothing, Nothing, Nothing}, Vector{Int64}}, options::Options{SymbolicRegression.CoreModule.OptionsStructModule.ComplexityMapping{Int64, Int64}, OperatorEnum, Node, Expression, @NamedTuple{}, MutationWeights, true, false, nothing, Nothing, 5}, regularization::Bool)\n        @ SymbolicRegression.LossFunctionsModule ~/.julia/packages/SymbolicRegression/MdISO/src/LossFunctions.jl:96\n     [24] eval_loss(tree::Expression{Float32, Node{Float32}, @NamedTuple{operators::Nothing, variable_names::Nothing}}, dataset::SymbolicRegression.CoreModule.DatasetModule.SubDataset{Float32, Float32, SymbolicRegression.CoreModule.DatasetModule.BasicDataset{Float32, Float32, Matrix{Float32}, Vector{Float32}, Nothing, @NamedTuple{}, Nothing, Nothing, Nothing, Nothing}, Vector{Int64}}, options::Options{SymbolicRegression.CoreModule.OptionsStructModule.ComplexityMapping{Int64, Int64}, OperatorEnum, Node, Expression, @NamedTuple{}, MutationWeights, true, false, nothing, Nothing, 5}; regularization::Bool, idx::Nothing)\n        @ SymbolicRegression.LossFunctionsModule ~/.julia/packages/SymbolicRegression/MdISO/src/LossFunctions.jl:155\n     [25] eval_loss\n        @ ~/.julia/packages/SymbolicRegression/MdISO/src/LossFunctions.jl:139 [inlined]\n     [26] #eval_cost#4\n        @ ~/.julia/packages/SymbolicRegression/MdISO/src/LossFunctions.jl:199 [inlined]\n     [27] eval_cost\n        @ ~/.julia/packages/SymbolicRegression/MdISO/src/LossFunctions.jl:193 [inlined]\n     [28] next_generation(dataset::SymbolicRegression.CoreModule.DatasetModule.SubDataset{Float32, Float32, SymbolicRegression.CoreModule.DatasetModule.BasicDataset{Float32, Float32, Matrix{Float32}, Vector{Float32}, Nothing, @NamedTuple{}, Nothing, Nothing, Nothing, Nothing}, Vector{Int64}}, member::PopMember{Float32, Float32, Expression{Float32, Node{Float32}, @NamedTuple{operators::Nothing, variable_names::Nothing}}}, temperature::Float64, curmaxsize::Int64, running_search_statistics::SymbolicRegression.AdaptiveParsimonyModule.RunningSearchStatistics, options::Options{SymbolicRegression.CoreModule.OptionsStructModule.ComplexityMapping{Int64, Int64}, OperatorEnum, Node, Expression, @NamedTuple{}, MutationWeights, true, false, nothing, Nothing, 5}; tmp_recorder::Dict{String, Any})\n        @ SymbolicRegression.MutateModule ~/.julia/packages/SymbolicRegression/MdISO/src/Mutate.jl:257\n     [29] next_generation\n        @ ~/.julia/packages/SymbolicRegression/MdISO/src/Mutate.jl:161 [inlined]\n     [30] reg_evol_cycle(dataset::SymbolicRegression.CoreModule.DatasetModule.SubDataset{Float32, Float32, SymbolicRegression.CoreModule.DatasetModule.BasicDataset{Float32, Float32, Matrix{Float32}, Vector{Float32}, Nothing, @NamedTuple{}, Nothing, Nothing, Nothing, Nothing}, Vector{Int64}}, pop::Population{Float32, Float32, Expression{Float32, Node{Float32}, @NamedTuple{operators::Nothing, variable_names::Nothing}}}, temperature::Float64, curmaxsize::Int64, running_search_statistics::SymbolicRegression.AdaptiveParsimonyModule.RunningSearchStatistics, options::Options{SymbolicRegression.CoreModule.OptionsStructModule.ComplexityMapping{Int64, Int64}, OperatorEnum, Node, Expression, @NamedTuple{}, MutationWeights, true, false, nothing, Nothing, 5}, record::Dict{String, Any})\n        @ SymbolicRegression.RegularizedEvolutionModule ~/.julia/packages/SymbolicRegression/MdISO/src/RegularizedEvolution.jl:29\n     [31] s_r_cycle(dataset::SymbolicRegression.CoreModule.DatasetModule.BasicDataset{Float32, Float32, Matrix{Float32}, Vector{Float32}, Nothing, @NamedTuple{}, Nothing, Nothing, Nothing, Nothing}, pop::Population{Float32, Float32, Expression{Float32, Node{Float32}, @NamedTuple{operators::Nothing, variable_names::Nothing}}}, ncycles::Int64, curmaxsize::Int64, running_search_statistics::SymbolicRegression.AdaptiveParsimonyModule.RunningSearchStatistics; verbosity::Int64, options::Options{SymbolicRegression.CoreModule.OptionsStructModule.ComplexityMapping{Int64, Int64}, OperatorEnum, Node, Expression, @NamedTuple{}, MutationWeights, true, false, nothing, Nothing, 5}, record::Dict{String, Any})\n        @ SymbolicRegression.SingleIterationModule ~/.julia/packages/SymbolicRegression/MdISO/src/SingleIteration.jl:43\n     [32] s_r_cycle\n        @ ~/.julia/packages/SymbolicRegression/MdISO/src/SingleIteration.jl:19 [inlined]\n     [33] _dispatch_s_r_cycle(in_pop::Population{Float32, Float32, Expression{Float32, Node{Float32}, @NamedTuple{operators::Nothing, variable_names::Nothing}}}, dataset::SymbolicRegression.CoreModule.DatasetModule.BasicDataset{Float32, Float32, Matrix{Float32}, Vector{Float32}, Nothing, @NamedTuple{}, Nothing, Nothing, Nothing, Nothing}, options::Options{SymbolicRegression.CoreModule.OptionsStructModule.ComplexityMapping{Int64, Int64}, OperatorEnum, Node, Expression, @NamedTuple{}, MutationWeights, true, false, nothing, Nothing, 5}; pop::Int64, out::Int64, iteration::Int64, verbosity::Int64, cur_maxsize::Int64, running_search_statistics::SymbolicRegression.AdaptiveParsimonyModule.RunningSearchStatistics)\n        @ SymbolicRegression ~/.julia/packages/SymbolicRegression/MdISO/src/SymbolicRegression.jl:1115\n     [34] _dispatch_s_r_cycle\n        @ ~/.julia/packages/SymbolicRegression/MdISO/src/SymbolicRegression.jl:1098 [inlined]\n     [35] macro expansion\n        @ ~/.julia/packages/SymbolicRegression/MdISO/src/SymbolicRegression.jl:959 [inlined]\n     [36] (::SymbolicRegression.var\"#62#67\"{SymbolicRegression.SearchUtilsModule.RuntimeOptions{:multithreading, 1, true, SRLogger{TensorBoardLogger.TBLogger{String, IOStream}}}, Options{SymbolicRegression.CoreModule.OptionsStructModule.ComplexityMapping{Int64, Int64}, OperatorEnum, Node, Expression, @NamedTuple{}, MutationWeights, true, false, nothing, Nothing, 5}, Population{Float32, Float32, Expression{Float32, Node{Float32}, @NamedTuple{operators::Nothing, variable_names::Nothing}}}, SymbolicRegression.AdaptiveParsimonyModule.RunningSearchStatistics, Int64, Int64, SymbolicRegression.CoreModule.DatasetModule.BasicDataset{Float32, Float32, Matrix{Float32}, Vector{Float32}, Nothing, @NamedTuple{}, Nothing, Nothing, Nothing, Nothing}, Int64, Int64})()\n        @ SymbolicRegression ~/.julia/packages/SymbolicRegression/MdISO/src/SearchUtils.jl:266\n    \n\njuliacall.JuliaError: TaskFailedException\nStacktrace:\n  [1] wait(t::Task)\n    @ Base ./task.jl:370\n  [2] fetch\n    @ ./task.jl:390 [inlined]\n  [3] _main_search_loop!(state::SymbolicRegression.SearchUtilsModule.SearchState{Float32, Float32, Expression{Float32, Node{Float32}, @NamedTuple{operators::Nothing, variable_names::Nothing}}, Task, Channel}, datasets::Vector{SymbolicRegression.CoreModule.DatasetModule.BasicDataset{Float32, Float32, Matrix{Float32}, Vector{Float32}, Nothing, @NamedTuple{}, Nothing, Nothing, Nothing, Nothing}}, ropt::SymbolicRegression.SearchUtilsModule.RuntimeOptions{:multithreading, 1, true, SRLogger{TensorBoardLogger.TBLogger{String, IOStream}}}, options::Options{SymbolicRegression.CoreModule.OptionsStructModule.ComplexityMapping{Int64, Int64}, OperatorEnum, Node, Expression, @NamedTuple{}, MutationWeights, true, false, nothing, Nothing, 5})\n    @ SymbolicRegression ~/.julia/packages/SymbolicRegression/MdISO/src/SymbolicRegression.jl:872\n  [4] _equation_search(datasets::Vector{SymbolicRegression.CoreModule.DatasetModule.BasicDataset{Float32, Float32, Matrix{Float32}, Vector{Float32}, Nothing, @NamedTuple{}, Nothing, Nothing, Nothing, Nothing}}, ropt::SymbolicRegression.SearchUtilsModule.RuntimeOptions{:multithreading, 1, true, SRLogger{TensorBoardLogger.TBLogger{String, IOStream}}}, options::Options{SymbolicRegression.CoreModule.OptionsStructModule.ComplexityMapping{Int64, Int64}, OperatorEnum, Node, Expression, @NamedTuple{}, MutationWeights, true, false, nothing, Nothing, 5}, saved_state::Nothing)\n    @ SymbolicRegression ~/.julia/packages/SymbolicRegression/MdISO/src/SymbolicRegression.jl:571\n  [5] equation_search(datasets::Vector{SymbolicRegression.CoreModule.DatasetModule.BasicDataset{Float32, Float32, Matrix{Float32}, Vector{Float32}, Nothing, @NamedTuple{}, Nothing, Nothing, Nothing, Nothing}}; options::Options{SymbolicRegression.CoreModule.OptionsStructModule.ComplexityMapping{Int64, Int64}, OperatorEnum, Node, Expression, @NamedTuple{}, MutationWeights, true, false, nothing, Nothing, 5}, saved_state::Nothing, runtime_options::Nothing, runtime_options_kws::@Kwargs{niterations::Int64, parallelism::String, numprocs::Nothing, procs::Nothing, addprocs_function::Nothing, heap_size_hint_in_bytes::Nothing, worker_imports::Nothing, runtests::Bool, return_state::Bool, run_id::String, verbosity::Int64, logger::SRLogger{TensorBoardLogger.TBLogger{String, IOStream}}, progress::Bool, v_dim_out::Val{1}})\n    @ SymbolicRegression ~/.julia/packages/SymbolicRegression/MdISO/src/SymbolicRegression.jl:561\n  [6] equation_search\n    @ ~/.julia/packages/SymbolicRegression/MdISO/src/SymbolicRegression.jl:542 [inlined]\n  [7] #equation_search#23\n    @ ~/.julia/packages/SymbolicRegression/MdISO/src/SymbolicRegression.jl:511 [inlined]\n  [8] equation_search\n    @ ~/.julia/packages/SymbolicRegression/MdISO/src/SymbolicRegression.jl:456 [inlined]\n  [9] #equation_search#24\n    @ ~/.julia/packages/SymbolicRegression/MdISO/src/SymbolicRegression.jl:535 [inlined]\n [10] pyjlany_call(self::typeof(equation_search), args_::Py, kwargs_::Py)\n    @ PythonCall.JlWrap ~/.julia/packages/PythonCall/L4cjh/src/JlWrap/any.jl:44\n [11] _pyjl_callmethod(f::Any, self_::Ptr{PythonCall.C.PyObject}, args_::Ptr{PythonCall.C.PyObject}, nargs::Int64)\n    @ PythonCall.JlWrap ~/.julia/packages/PythonCall/L4cjh/src/JlWrap/base.jl:73\n [12] _pyjl_callmethod(o::Ptr{PythonCall.C.PyObject}, args::Ptr{PythonCall.C.PyObject})\n    @ PythonCall.JlWrap.Cjl ~/.julia/packages/PythonCall/L4cjh/src/JlWrap/C.jl:63\n\n    nested task error: TaskFailedException\n    Stacktrace:\n     [1] wait(t::Task)\n       @ Base ./task.jl:370\n     [2] fetch\n       @ ./task.jl:390 [inlined]\n     [3] #63\n       @ ~/.julia/packages/SymbolicRegression/MdISO/src/SymbolicRegression.jl:976\n    \n        nested task error: DomainError with Inf:\n        tan(x) is only defined for finite x.\n        Stacktrace:\n          [1] tan_domain_error(x::Float32)\n            @ Base.Math ./special/trig.jl:215\n          [2] tan(x::Float32)\n            @ Base.Math ./special/trig.jl:226\n          [3] macro expansion\n            @ ~/.julia/packages/DynamicExpressions/wtMlL/ext/DynamicExpressionsLoopVectorizationExt.jl:79 [inlined]\n          [4] macro expansion\n            @ ~/.julia/packages/LoopVectorization/ImqiY/src/condense_loopset.jl:1179 [inlined]\n          [5] deg1_l2_ll0_lr0_eval(tree::Node{Float32}, cX::SubArray{Float32, 2, Matrix{Float32}, Tuple{Base.Slice{Base.OneTo{Int64}}, Vector{Int64}}, false}, op::typeof(tan), op_l::typeof(/), eval_options::EvalOptions{true, false, true, Nothing})\n            @ DynamicExpressionsLoopVectorizationExt ~/.julia/packages/DynamicExpressions/wtMlL/ext/DynamicExpressionsLoopVectorizationExt.jl:77\n          [6] macro expansion\n            @ ~/.julia/packages/DynamicExpressions/wtMlL/src/Evaluate.jl:438 [inlined]\n          [7] dispatch_deg1_l2_ll0_lr0_eval\n            @ ~/.julia/packages/DynamicExpressions/wtMlL/src/Evaluate.jl:422 [inlined]\n          [8] macro expansion\n            @ ~/.julia/packages/DynamicExpressions/wtMlL/src/Evaluate.jl:402 [inlined]\n          [9] dispatch_deg1_eval(tree::Node{Float32}, cX::SubArray{Float32, 2, Matrix{Float32}, Tuple{Base.Slice{Base.OneTo{Int64}}, Vector{Int64}}, false}, op_idx::UInt8, operators::OperatorEnum{Tuple{typeof(+), typeof(-), typeof(*), typeof(/)}, Tuple{typeof(cos), typeof(sin), typeof(tan), typeof(safe_log), typeof(safe_sqrt), typeof(inv)}}, eval_options::EvalOptions{true, false, true, Nothing})\n            @ DynamicExpressions.EvaluateModule ~/.julia/packages/DynamicExpressions/wtMlL/src/Evaluate.jl:375\n         [10] _eval_tree_array(tree::Node{Float32}, cX::SubArray{Float32, 2, Matrix{Float32}, Tuple{Base.Slice{Base.OneTo{Int64}}, Vector{Int64}}, false}, operators::OperatorEnum{Tuple{typeof(+), typeof(-), typeof(*), typeof(/)}, Tuple{typeof(cos), typeof(sin), typeof(tan), typeof(safe_log), typeof(safe_sqrt), typeof(inv)}}, eval_options::EvalOptions{true, false, true, Nothing})\n            @ DynamicExpressions.EvaluateModule ~/.julia/packages/DynamicExpressions/wtMlL/src/Evaluate.jl:277\n         [11] macro expansion\n            @ ~/.julia/packages/DynamicExpressions/wtMlL/src/Evaluate.jl:350 [inlined]\n         [12] dispatch_deg2_eval(tree::Node{Float32}, cX::SubArray{Float32, 2, Matrix{Float32}, Tuple{Base.Slice{Base.OneTo{Int64}}, Vector{Int64}}, false}, op_idx::UInt8, operators::OperatorEnum{Tuple{typeof(+), typeof(-), typeof(*), typeof(/)}, Tuple{typeof(cos), typeof(sin), typeof(tan), typeof(safe_log), typeof(safe_sqrt), typeof(inv)}}, eval_options::EvalOptions{true, false, true, Nothing})\n            @ DynamicExpressions.EvaluateModule ~/.julia/packages/DynamicExpressions/wtMlL/src/Evaluate.jl:321\n         [13] _eval_tree_array(tree::Node{Float32}, cX::SubArray{Float32, 2, Matrix{Float32}, Tuple{Base.Slice{Base.OneTo{Int64}}, Vector{Int64}}, false}, operators::OperatorEnum{Tuple{typeof(+), typeof(-), typeof(*), typeof(/)}, Tuple{typeof(cos), typeof(sin), typeof(tan), typeof(safe_log), typeof(safe_sqrt), typeof(inv)}}, eval_options::EvalOptions{true, false, true, Nothing})\n            @ DynamicExpressions.EvaluateModule ~/.julia/packages/DynamicExpressions/wtMlL/src/Evaluate.jl:282\n         [14] macro expansion\n            @ ~/.julia/packages/DynamicExpressions/wtMlL/src/Evaluate.jl:365 [inlined]\n         [15] dispatch_deg2_eval(tree::Node{Float32}, cX::SubArray{Float32, 2, Matrix{Float32}, Tuple{Base.Slice{Base.OneTo{Int64}}, Vector{Int64}}, false}, op_idx::UInt8, operators::OperatorEnum{Tuple{typeof(+), typeof(-), typeof(*), typeof(/)}, Tuple{typeof(cos), typeof(sin), typeof(tan), typeof(safe_log), typeof(safe_sqrt), typeof(inv)}}, eval_options::EvalOptions{true, false, true, Nothing})\n            @ DynamicExpressions.EvaluateModule ~/.julia/packages/DynamicExpressions/wtMlL/src/Evaluate.jl:321\n         [16] _eval_tree_array(tree::Node{Float32}, cX::SubArray{Float32, 2, Matrix{Float32}, Tuple{Base.Slice{Base.OneTo{Int64}}, Vector{Int64}}, false}, operators::OperatorEnum{Tuple{typeof(+), typeof(-), typeof(*), typeof(/)}, Tuple{typeof(cos), typeof(sin), typeof(tan), typeof(safe_log), typeof(safe_sqrt), typeof(inv)}}, eval_options::EvalOptions{true, false, true, Nothing})\n            @ DynamicExpressions.EvaluateModule ~/.julia/packages/DynamicExpressions/wtMlL/src/Evaluate.jl:282\n         [17] eval_tree_array(tree::Node{Float32}, cX::SubArray{Float32, 2, Matrix{Float32}, Tuple{Base.Slice{Base.OneTo{Int64}}, Vector{Int64}}, false}, operators::OperatorEnum{Tuple{typeof(+), typeof(-), typeof(*), typeof(/)}, Tuple{typeof(cos), typeof(sin), typeof(tan), typeof(safe_log), typeof(safe_sqrt), typeof(inv)}}; eval_options::EvalOptions{true, false, true, Nothing}, _deprecated_kws::@Kwargs{})\n            @ DynamicExpressions.EvaluateModule ~/.julia/packages/DynamicExpressions/wtMlL/src/Evaluate.jl:227\n         [18] eval_tree_array\n            @ ~/.julia/packages/DynamicExpressions/wtMlL/src/Evaluate.jl:200 [inlined]\n         [19] eval_tree_array(ex::Expression{Float32, Node{Float32}, @NamedTuple{operators::Nothing, variable_names::Nothing}}, cX::SubArray{Float32, 2, Matrix{Float32}, Tuple{Base.Slice{Base.OneTo{Int64}}, Vector{Int64}}, false}, operators::OperatorEnum{Tuple{typeof(+), typeof(-), typeof(*), typeof(/)}, Tuple{typeof(cos), typeof(sin), typeof(tan), typeof(safe_log), typeof(safe_sqrt), typeof(inv)}}; kws::@Kwargs{eval_options::EvalOptions{true, false, true, Nothing}})\n            @ DynamicExpressions.ExpressionModule ~/.julia/packages/DynamicExpressions/wtMlL/src/Expression.jl:436\n         [20] eval_tree_array(tree::Expression{Float32, Node{Float32}, @NamedTuple{operators::Nothing, variable_names::Nothing}}, X::SubArray{Float32, 2, Matrix{Float32}, Tuple{Base.Slice{Base.OneTo{Int64}}, Vector{Int64}}, false}, options::Options{SymbolicRegression.CoreModule.OptionsStructModule.ComplexityMapping{Int64, Int64}, OperatorEnum, Node, Expression, @NamedTuple{}, MutationWeights, true, false, nothing, Nothing, 5}; turbo::Nothing, bumper::Nothing, kws::@Kwargs{})\n            @ SymbolicRegression.InterfaceDynamicExpressionsModule ~/.julia/packages/SymbolicRegression/MdISO/src/InterfaceDynamicExpressions.jl:81\n         [21] eval_tree_array\n            @ ~/.julia/packages/SymbolicRegression/MdISO/src/InterfaceDynamicExpressions.jl:61 [inlined]\n         [22] eval_tree_dispatch\n            @ ~/.julia/packages/SymbolicRegression/MdISO/src/LossFunctions.jl:68 [inlined]\n         [23] _eval_loss(tree::Expression{Float32, Node{Float32}, @NamedTuple{operators::Nothing, variable_names::Nothing}}, dataset::SymbolicRegression.CoreModule.DatasetModule.SubDataset{Float32, Float32, SymbolicRegression.CoreModule.DatasetModule.BasicDataset{Float32, Float32, Matrix{Float32}, Vector{Float32}, Nothing, @NamedTuple{}, Nothing, Nothing, Nothing, Nothing}, Vector{Int64}}, options::Options{SymbolicRegression.CoreModule.OptionsStructModule.ComplexityMapping{Int64, Int64}, OperatorEnum, Node, Expression, @NamedTuple{}, MutationWeights, true, false, nothing, Nothing, 5}, regularization::Bool)\n            @ SymbolicRegression.LossFunctionsModule ~/.julia/packages/SymbolicRegression/MdISO/src/LossFunctions.jl:96\n         [24] eval_loss(tree::Expression{Float32, Node{Float32}, @NamedTuple{operators::Nothing, variable_names::Nothing}}, dataset::SymbolicRegression.CoreModule.DatasetModule.SubDataset{Float32, Float32, SymbolicRegression.CoreModule.DatasetModule.BasicDataset{Float32, Float32, Matrix{Float32}, Vector{Float32}, Nothing, @NamedTuple{}, Nothing, Nothing, Nothing, Nothing}, Vector{Int64}}, options::Options{SymbolicRegression.CoreModule.OptionsStructModule.ComplexityMapping{Int64, Int64}, OperatorEnum, Node, Expression, @NamedTuple{}, MutationWeights, true, false, nothing, Nothing, 5}; regularization::Bool, idx::Nothing)\n            @ SymbolicRegression.LossFunctionsModule ~/.julia/packages/SymbolicRegression/MdISO/src/LossFunctions.jl:155\n         [25] eval_loss\n            @ ~/.julia/packages/SymbolicRegression/MdISO/src/LossFunctions.jl:139 [inlined]\n         [26] #eval_cost#4\n            @ ~/.julia/packages/SymbolicRegression/MdISO/src/LossFunctions.jl:199 [inlined]\n         [27] eval_cost\n            @ ~/.julia/packages/SymbolicRegression/MdISO/src/LossFunctions.jl:193 [inlined]\n         [28] next_generation(dataset::SymbolicRegression.CoreModule.DatasetModule.SubDataset{Float32, Float32, SymbolicRegression.CoreModule.DatasetModule.BasicDataset{Float32, Float32, Matrix{Float32}, Vector{Float32}, Nothing, @NamedTuple{}, Nothing, Nothing, Nothing, Nothing}, Vector{Int64}}, member::PopMember{Float32, Float32, Expression{Float32, Node{Float32}, @NamedTuple{operators::Nothing, variable_names::Nothing}}}, temperature::Float64, curmaxsize::Int64, running_search_statistics::SymbolicRegression.AdaptiveParsimonyModule.RunningSearchStatistics, options::Options{SymbolicRegression.CoreModule.OptionsStructModule.ComplexityMapping{Int64, Int64}, OperatorEnum, Node, Expression, @NamedTuple{}, MutationWeights, true, false, nothing, Nothing, 5}; tmp_recorder::Dict{String, Any})\n            @ SymbolicRegression.MutateModule ~/.julia/packages/SymbolicRegression/MdISO/src/Mutate.jl:257\n         [29] next_generation\n            @ ~/.julia/packages/SymbolicRegression/MdISO/src/Mutate.jl:161 [inlined]\n         [30] reg_evol_cycle(dataset::SymbolicRegression.CoreModule.DatasetModule.SubDataset{Float32, Float32, SymbolicRegression.CoreModule.DatasetModule.BasicDataset{Float32, Float32, Matrix{Float32}, Vector{Float32}, Nothing, @NamedTuple{}, Nothing, Nothing, Nothing, Nothing}, Vector{Int64}}, pop::Population{Float32, Float32, Expression{Float32, Node{Float32}, @NamedTuple{operators::Nothing, variable_names::Nothing}}}, temperature::Float64, curmaxsize::Int64, running_search_statistics::SymbolicRegression.AdaptiveParsimonyModule.RunningSearchStatistics, options::Options{SymbolicRegression.CoreModule.OptionsStructModule.ComplexityMapping{Int64, Int64}, OperatorEnum, Node, Expression, @NamedTuple{}, MutationWeights, true, false, nothing, Nothing, 5}, record::Dict{String, Any})\n            @ SymbolicRegression.RegularizedEvolutionModule ~/.julia/packages/SymbolicRegression/MdISO/src/RegularizedEvolution.jl:29\n         [31] s_r_cycle(dataset::SymbolicRegression.CoreModule.DatasetModule.BasicDataset{Float32, Float32, Matrix{Float32}, Vector{Float32}, Nothing, @NamedTuple{}, Nothing, Nothing, Nothing, Nothing}, pop::Population{Float32, Float32, Expression{Float32, Node{Float32}, @NamedTuple{operators::Nothing, variable_names::Nothing}}}, ncycles::Int64, curmaxsize::Int64, running_search_statistics::SymbolicRegression.AdaptiveParsimonyModule.RunningSearchStatistics; verbosity::Int64, options::Options{SymbolicRegression.CoreModule.OptionsStructModule.ComplexityMapping{Int64, Int64}, OperatorEnum, Node, Expression, @NamedTuple{}, MutationWeights, true, false, nothing, Nothing, 5}, record::Dict{String, Any})\n            @ SymbolicRegression.SingleIterationModule ~/.julia/packages/SymbolicRegression/MdISO/src/SingleIteration.jl:43\n         [32] s_r_cycle\n            @ ~/.julia/packages/SymbolicRegression/MdISO/src/SingleIteration.jl:19 [inlined]\n         [33] _dispatch_s_r_cycle(in_pop::Population{Float32, Float32, Expression{Float32, Node{Float32}, @NamedTuple{operators::Nothing, variable_names::Nothing}}}, dataset::SymbolicRegression.CoreModule.DatasetModule.BasicDataset{Float32, Float32, Matrix{Float32}, Vector{Float32}, Nothing, @NamedTuple{}, Nothing, Nothing, Nothing, Nothing}, options::Options{SymbolicRegression.CoreModule.OptionsStructModule.ComplexityMapping{Int64, Int64}, OperatorEnum, Node, Expression, @NamedTuple{}, MutationWeights, true, false, nothing, Nothing, 5}; pop::Int64, out::Int64, iteration::Int64, verbosity::Int64, cur_maxsize::Int64, running_search_statistics::SymbolicRegression.AdaptiveParsimonyModule.RunningSearchStatistics)\n            @ SymbolicRegression ~/.julia/packages/SymbolicRegression/MdISO/src/SymbolicRegression.jl:1115\n         [34] _dispatch_s_r_cycle\n            @ ~/.julia/packages/SymbolicRegression/MdISO/src/SymbolicRegression.jl:1098 [inlined]\n         [35] macro expansion\n            @ ~/.julia/packages/SymbolicRegression/MdISO/src/SymbolicRegression.jl:959 [inlined]\n         [36] (::SymbolicRegression.var\"#62#67\"{SymbolicRegression.SearchUtilsModule.RuntimeOptions{:multithreading, 1, true, SRLogger{TensorBoardLogger.TBLogger{String, IOStream}}}, Options{SymbolicRegression.CoreModule.OptionsStructModule.ComplexityMapping{Int64, Int64}, OperatorEnum, Node, Expression, @NamedTuple{}, MutationWeights, true, false, nothing, Nothing, 5}, Population{Float32, Float32, Expression{Float32, Node{Float32}, @NamedTuple{operators::Nothing, variable_names::Nothing}}}, SymbolicRegression.AdaptiveParsimonyModule.RunningSearchStatistics, Int64, Int64, SymbolicRegression.CoreModule.DatasetModule.BasicDataset{Float32, Float32, Matrix{Float32}, Vector{Float32}, Nothing, @NamedTuple{}, Nothing, Nothing, Nothing, Nothing}, Int64, Int64})()\n            @ SymbolicRegression ~/.julia/packages/SymbolicRegression/MdISO/src/SearchUtils.jl:266\nsrun: error: cmp035: task 0: Exited with exit code 1\nsrun: launch/slurm: _step_signal: Terminating StepId=7161616.0\n\n\n### Version\n\nVersion: 1.5.8\n\n### Operating System\n\n_No response_\n\n### Package Manager\n\nNone\n\n### Interface\n\nJupyter Notebook\n\n### Relevant log output\n\n```shell\n\n```\n\n### Extra Info\n\n_No response_",
        "comments": {
          "nodes": [
            {
              "author": {
                "login": "MilesCranmer"
              },
              "body": "This looks like a real bug! We probably need a `safe_tan`. I think nobody had run into this issue up to now so it was never noticed. \n\nFor the moment, you can fix it locally by defining your own `safe_tan` operator, maybe like `unary_operators=[\"safe_tan(x) = isfinite(x) ? tan(x) : convert(typeof(x), NaN)\"], extra_sympy_mappings={\"safe_tan\": lambda x: sympy.tan(x)}`",
              "createdAt": "2025-05-30T20:55:16Z"
            }
          ],
          "pageInfo": {
            "hasNextPage": false,
            "endCursor": "Y3Vyc29yOnYyOpHOrkCBvg=="
          }
        }
      }
    }
  }
}